"use strict";
// ------------------------------------------------------------------------
// Copyright (c) 2018-2024 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License.
// ------------------------------------------------------------------------
// Parses and computes a simulation of CSS animation-direction
/** @module end-user | The lines bellow convey information for the end-user */
/**
 * ## Description
 *
 * ABeamer implements the animation direction in a similar way of the
 * CSS `animation-direction` property.
 * Currently is supported: `normal`, `reverse`, `alternate`, `alternate-reverse`
 *
 * The value is defined per property.
 * Both textual and numeric values are supported.
 *
 * Use `iterationCount` to repeat the cycle.
 * To ensure that `normal` and `reverse` finish their cycles at the same time,
 * the `reverse` repeats the same value at the beginning of the next cycle.
 *
 * @see gallery/animate-loop
 */
var ABeamer;
(function (ABeamer) {
    // #generate-group-section
    // ------------------------------------------------------------------------
    //                               Animation Direction
    // ------------------------------------------------------------------------
    // The following section contains data for the end-user
    // generated by `gulp build-definition-files`
    // -------------------------------
    // #export-section-start: release
    let Directions;
    (function (Directions) {
        Directions[Directions["normal"] = 0] = "normal";
        Directions[Directions["reverse"] = 1] = "reverse";
        Directions[Directions["alternate"] = 2] = "alternate";
        Directions[Directions["alternate-reverse"] = 3] = "alternate-reverse";
    })(Directions = ABeamer.Directions || (ABeamer.Directions = {}));
    const DIRECTION_TO_DIR_PAIR = [[1, 1], [-1, -1], [1, -1],
        [-1, 1]];
    function _propDirToDirPair(direction) {
        if (direction === undefined) {
            return DIRECTION_TO_DIR_PAIR[Directions.normal];
        }
        if (typeof direction === 'string') {
            direction = Directions[direction];
        }
        if (direction < 0 || direction >= DIRECTION_TO_DIR_PAIR.length) {
            ABeamer.throwErr(`Direction has an invalid value`);
        }
        return DIRECTION_TO_DIR_PAIR[direction];
    }
    ABeamer._propDirToDirPair = _propDirToDirPair;
    // ------------------------------------------------------------------------
    //                               Compute
    // ------------------------------------------------------------------------
    function _computeIterationCount(i, frameI, dirPair, framesPerCycle) {
        // ensures that if reach the end of the cycle and needs to alternate,
        // one extra frame will be on the same position
        if (dirPair[0] !== dirPair[1] &&
            ((i + 1) % framesPerCycle === 0)) {
            return frameI;
        }
        const isOddInt = Math.floor((i + 1) / framesPerCycle) % 2;
        frameI += dirPair[isOddInt];
        if (frameI >= framesPerCycle) {
            frameI -= framesPerCycle;
        }
        else if (frameI < 0) {
            frameI += framesPerCycle;
        }
        return frameI;
    }
    ABeamer._computeIterationCount = _computeIterationCount;
})(ABeamer || (ABeamer = {}));
//# sourceMappingURL=animation-direction.js.map