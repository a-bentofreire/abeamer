"use strict";
// ------------------------------------------------------------------------
// Copyright (c) 2018-2024 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License.
// ------------------------------------------------------------------------

// Implements a list of built-in functions

/** @module end-user | The lines bellow convey information for the end-user */

/**
 * ## Description
 *
 * A **function** transforms zero or more textual or numerical parameters
 * into another value.
 * Functions are used inside an expression, and support remote rendering.
 * The user can create its own custom functions but only built-in functions
 * and official plugins can create functions that support [teleportation](teleporter.md).
 *
 * ## Core functions
 * **WARNING!** In the ABeamer 2.x these core functions will move `core-functions` plugin.
 * To prevent breaking changes include now the js script `core-functions.js` on the html file.
 *
 * ABeamer has the following core functions:
 *
 * - `sin` - 'sine' trigonometric function.
 * - `cos` - 'cosine' trigonometric function.
 * - `tan` - 'tangent' trigonometric function.
 *
 * - `exp` - 2^x
 * - `log` - ln
 * - `log10` - base 10 logarithm.
 *
 * - `abs` - absolute value.
 * - `sign` - sign function `v != 0 ? v / |v| : 0`.
 *
 * - `random` - random number between [0, 1].
 * - `ceil`- always rounds up.
 * - `floor`- always rounds down.
 * - `sqrt` - square root.
 * - `round` - round to the nearest integer value.
 * - `downRound` - similar to round, but it guaranties that if fractional
 * part is 0.5, it will always round down.
 *
 * - `toNumber` - converts a textual parameter into a numerical parameter.
 * - `toString` - converts a numerical parameter into a textual parameter.
 *
 * - `uppercase` - returns the uppercase of the textual parameter.
 * - `lowercase` - returns the lowercase of the textual parameter.
 * - `capitalize` -returns the uppercase of the first letter of each word
 * - `substr` - returns the a section of the 1st parameter.
 *  The 2nd parameter is the start value and the 3rd parameter is the length.
 *  If the 3rd parameter is less than 0, than is considered until the end.
 *
 * - `iff` - if the 1st numerical parameter is different from 0,
 * it returns the 2nd parameter, otherwise it returns the 3rd paramter.
 * This function doesn't supports [lazy evaluation](https://en.wikipedia.org/wiki/Lazy_evaluation).
 *
 * - `case` - the 1st numerical parameter is a zero index to select which
 * parameters to return.
 * This function doesn't supports [lazy evaluation](https://en.wikipedia.org/wiki/Lazy_evaluation).
 *
 * - `get` - returns the numerical N-value of a 0-base array.
 *
 * - `slice` - returns a subarray starting from `start` to `end-1` of a 0-base array.
 *
 * ## Examples
 *
 * @example = substr('ABeamer', 4, 4)
 * @example = round(12.4)
 * @example = get([10,30,15],1)
 * it returns `30`
 * @example = slice([10,30,15,40],1, 3)
 * it returns `[30, 15]`
 *
 * ## Arrays
 *
 * Since ABeamer 1.6 that single numerical argument functions also support arrays.
 * The operation is perform for each element, and it returns an array.
 * The array functions can be composed.
 *
 * @example = round(sqrt([12.4, 75, 10]))
 *
 */
namespace ABeamer {

  // #generate-group-section
  // ------------------------------------------------------------------------
  //                               Functions
  // ------------------------------------------------------------------------

  // The following section contains data for the end-user
  // generated by `gulp build-definition-files`
  // -------------------------------
  // #export-section-start: release

  export const enum ExFuncParamType {
    Any,
    Number,
    String,
    Array,
  }


  export interface ExFuncParam {
    paType?: ExFuncParamType;
    sValue?: string;
    numValue?: number;
    arrayValue?: number[];
  }


  export type _CheckParamFunc = (req: ExFuncReq, paramCount: uint,
    paramTypes?: ExFuncParamType[]) => void;


  export interface ExFuncReq {
    args: ABeamerArgs;
    req?: ExFuncReq;
    res?: ExFuncParam;

    checkParams: _CheckParamFunc;
  }


  export type ExprFuncParams = ExFuncParam[];

  export type ExFunction = (params: ExprFuncParams, req?: ExFuncReq) => void;

  // #export-section-end: release
  // -------------------------------

  export const _exFunctions: { [name: string]: ExFunction } = {};

  // ------------------------------------------------------------------------
  //                               Built-in functions
  // ------------------------------------------------------------------------

  /**
   * Generic handler for math functions that have 1 numerical input
   * and 1 numerical output.
   */
  function _math1ParamFunc(params: ExprFuncParams, req: ExFuncReq,
    f: (param1: number) => number) {

    arrayInputHelper(params, req, 1, undefined, f);
  }


  /**
   * Generic handler for string functions that have 1 textual input
   * and 1 textual output.
   */
  function _str1ParamFunc(params: ExprFuncParams, req: ExFuncReq,
    f: (param1: string) => string) {

    req.checkParams(req, 1, [ExFuncParamType.String]);
    req.res.paType = ExFuncParamType.String;
    req.res.sValue = f(params[0].sValue);
  }


  _exFunctions['sin'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _math1ParamFunc(params, req, Math.sin);
  };


  _exFunctions['cos'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _math1ParamFunc(params, req, Math.cos);
  };


  _exFunctions['tan'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _math1ParamFunc(params, req, Math.tan);
  };


  _exFunctions['round'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _math1ParamFunc(params, req, Math.round);
  };


  _exFunctions['downRound'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _math1ParamFunc(params, req, downRound);
  };


  _exFunctions['ceil'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _math1ParamFunc(params, req, Math.ceil);
  };


  _exFunctions['floor'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _math1ParamFunc(params, req, Math.floor);
  };


  _exFunctions['sqrt'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _math1ParamFunc(params, req, Math.sqrt);
  };


  _exFunctions['exp'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _math1ParamFunc(params, req, Math.exp);
  };


  _exFunctions['log'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _math1ParamFunc(params, req, Math.log);
  };


  _exFunctions['log10'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _math1ParamFunc(params, req, Math.log10);
  };


  _exFunctions['abs'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _math1ParamFunc(params, req, Math.abs);
  };


  _exFunctions['sign'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _math1ParamFunc(params, req, (v: number) => v < 0 ? -1 : (v > 0 ? 1 : 0));
  };


  _exFunctions['random'] = (_params: ExprFuncParams, req?: ExFuncReq) => {
    req.checkParams(req, 0);
    req.res.paType = ExFuncParamType.Number;
    req.res.numValue = Math.random();
  };


  _exFunctions['toNumber'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    req.checkParams(req, 1, [ExFuncParamType.String]);
    req.res.paType = ExFuncParamType.Number;
    req.res.numValue = parseFloat(params[0].sValue);
  };


  // @ts-ignore   TypeScript bug :-(
  _exFunctions['toString'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    req.checkParams(req, 1, [ExFuncParamType.Number]);
    req.res.paType = ExFuncParamType.String;
    req.res.sValue = params[0].numValue.toString();
  };


  _exFunctions['uppercase'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _str1ParamFunc(params, req, (s) => s.toUpperCase());
  };


  _exFunctions['lowercase'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _str1ParamFunc(params, req, (s) => s.toUpperCase());
  };


  _exFunctions['capitalize'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    _str1ParamFunc(params, req, (s) => s.replace(/\b(\w)/, (_all, p) => p.toUpperCase()));
  };


  _exFunctions['substr'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    req.checkParams(req, 3, [ExFuncParamType.String, ExFuncParamType.Number, ExFuncParamType.Number]);
    req.res.paType = ExFuncParamType.String;
    req.res.sValue = params[0].sValue.substr(params[1].numValue,
      params[2].numValue < 0 ? undefined : params[2].numValue);
  };


  _exFunctions['iff'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    req.checkParams(req, 3, [ExFuncParamType.Number, ExFuncParamType.Any, ExFuncParamType.Any]);
    const res = params[params[0].numValue ? 1 : 2];
    req.res.paType = res.paType;
    req.res.sValue = res.sValue;
    req.res.numValue = res.numValue;
  };


  _exFunctions['case'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    // @TODO: check params
    const res = params[Math.round(params[0].numValue) + 1];
    req.res.paType = res.paType;
    req.res.sValue = res.sValue;
    req.res.numValue = res.numValue;
  };


  _exFunctions['get'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    req.checkParams(req, 2, [ExFuncParamType.Array, ExFuncParamType.Number]);
    const index = Math.round(params[1].numValue);
    const arr = params[0].arrayValue;
    if (index < 0 || index >= arr.length) {
      throwErr('Invalid indexing');
    }
    req.res.paType = ExFuncParamType.Number;
    req.res.numValue = arr[index];
  };


  _exFunctions['slice'] = (params: ExprFuncParams, req?: ExFuncReq) => {
    req.checkParams(req, 3, [ExFuncParamType.Array, ExFuncParamType.Number, ExFuncParamType.Number]);
    const start = Math.round(params[1].numValue);
    const end = Math.round(params[2].numValue);
    const arr = params[0].arrayValue;
    if (start < 0 || start >= arr.length || end < 0 || end >= arr.length) {
      throwErr('Invalid indexing');
    }
    req.res.paType = ExFuncParamType.Array;
    req.res.arrayValue = arr.slice(start, end);
  };
}
