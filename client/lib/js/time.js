"use strict";
// ------------------------------------------------------------------------
// Copyright (c) 2018-2024 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License.
// ------------------------------------------------------------------------
/** @module end-user | The lines bellow convey information for the end-user */
/**
 * ## Description
 *
 * Provides time functions to convert between minutes/seconds/milliseconds into frames.
 * Internally ABeamer only works with frames.
 *
 */
var ABeamer;
(function (ABeamer) {
    // #generate-group-section
    // ------------------------------------------------------------------------
    //                               Time
    // ------------------------------------------------------------------------
    // The following section contains data for the end-user
    // generated by `gulp build-definition-files`
    // -------------------------------
    // #export-section-start: release
    /**
     * List of supported Time Units.
     * `%` can only be used if there is a parent time reference.
     */
    let TimeUnit;
    (function (TimeUnit) {
        TimeUnit[TimeUnit["f"] = 0] = "f";
        TimeUnit[TimeUnit["ms"] = 1] = "ms";
        TimeUnit[TimeUnit["s"] = 2] = "s";
        TimeUnit[TimeUnit["m"] = 3] = "m";
        TimeUnit[TimeUnit["%"] = 4] = "%";
    })(TimeUnit = ABeamer.TimeUnit || (ABeamer.TimeUnit = {}));
    // #export-section-end: release
    // -------------------------------
    // ------------------------------------------------------------------------
    //                               frame2Time
    // ------------------------------------------------------------------------
    /**
     * Converts frames into time defined by the `unit`.
     */
    function frame2Time(frame, fps, unit, maxPrecision) {
        switch (unit) {
            case TimeUnit.f:
                return frame.toString();
            case TimeUnit.ms:
                frame = frame * 1000;
                break;
            case TimeUnit.m:
                frame = frame / 60;
                break;
        }
        const unitTime = frame / fps;
        const divider = Math.pow(10, (maxPrecision || 4));
        return (ABeamer.downRound(unitTime * divider) / divider).toString() + TimeUnit[unit];
    }
    ABeamer.frame2Time = frame2Time;
    // ------------------------------------------------------------------------
    //                               parseTimeHandler
    // ------------------------------------------------------------------------
    /**
     *  Parses positions or durations in f/ms/s/m in number of value.
     *  Also supports adding or subtracting from the reference.
     *  Floating point frames can be used together with toInt=false for `item-delay`.
     *
     * @param toInt rounds the nearest int. if the float part is 0.5, it rounds to the lower
     */
    function parseTimeHandler(timeOrFrame, args, defaultTimeOrFrame, referenceFrame, toInt = true) {
        if (timeOrFrame === undefined || timeOrFrame === '') {
            timeOrFrame = defaultTimeOrFrame;
        }
        let shift = '';
        const story = args.story;
        if (typeof timeOrFrame === 'function') {
            timeOrFrame = timeOrFrame(args);
        }
        let defaultUnit = story.defaultUnit;
        let isStringTime = typeof timeOrFrame === 'string';
        if (isStringTime) {
            const exprTime = ABeamer.ifExprCalc(timeOrFrame, args);
            if (exprTime !== undefined) {
                timeOrFrame = exprTime;
                isStringTime = typeof timeOrFrame === 'string';
            }
        }
        if (isStringTime) {
            const [, sShift, sValue, suffix] = timeOrFrame
                .match(/^([+\-])?([\d\.]+)([\w%]+)$/) || ['', '', '', ''];
            defaultUnit = TimeUnit[suffix];
            if (defaultUnit === undefined) {
                throw `Unknown time of ${timeOrFrame}`;
            }
            timeOrFrame = parseFloat(sValue);
            shift = sShift;
        }
        let res = timeOrFrame;
        switch (defaultUnit) {
            case TimeUnit.ms:
                res = res * story.fps / 1000.0;
                break;
            case TimeUnit.s:
                res = res * story.fps;
                break;
            case TimeUnit.m:
                res = res * story.fps * 60;
                break;
            case TimeUnit['%']:
                res = defaultTimeOrFrame * res / 100;
                break;
        }
        switch (shift) {
            case '+':
                res = referenceFrame + res;
                break;
            case '-':
                res = referenceFrame - res;
                break;
        }
        // this is delta is used to minimize the problems of using integer frames
        // which happens when there is a 0.5 and can overlap with the next animation
        return toInt ? ABeamer.downRound(res) : res;
    }
    ABeamer.parseTimeHandler = parseTimeHandler;
})(ABeamer || (ABeamer = {}));
//# sourceMappingURL=time.js.map