"use strict";
// ------------------------------------------------------------------------
// Copyright (c) 2018-2024 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License.
// ------------------------------------------------------------------------
// Implementation of Tasks
/** @module end-user | The lines bellow convey information for the end-user */
/**
 * ## Description
 *
 * A **task** is a function executed at the beginning of `addAnimations`,
 * before selector and properties information is processed,
 * and has the following goals:
 *
 * - *Setup*: A setup allows to prepare elements for further processing.
 *     An example is text splitting. text splitting prepares DOM for individual
 *     character manipulation.
 *     Setup tasks can stop the processing of a `addAnimations`, and might not
 *     require a selector..
 *
 * - *Wrapping*: Only `addAnimations` can be stored in a JSON file or sent
 *     for remote rendering. In this case, methods such as `addStills` and scene transitions
 *     need to be wrapped in a task.
 *     Wrapping tasks can stop the processing of a `addAnimations`, and might not
 *     require a selector.
 *
 * - *Asset creation*: A task can create an asset avoiding the need of loading external
 *     assets such as svg shape files.
 *
 * - *Complex animations*: A task can simplify the creation of a complex animation.
 *
 * ## F/X
 *
 * If you just want to do a single-shot animation, use `scene.addAnimations`,
 * but if you want to reuse the animation or want to break down the complexity
 * into multiple parts, the best is to create a task.
 *
 * A task implementation is a function with the following syntax:
 * ```typescript
 * function myTaskFunc(anime: Animation, wkTask: WorkTask,
 *   params: FactoryTaskParams, stage?: uint, args?: ABeamerArgs): TaskResult;
 * ```
 * And add this task to ABeamer using `ABeamer.pluginManager.addTasks([['my-task', myTaskFunc]]);`.
 *
 * If the task just uses plain DOM, the simplest is to:
 * - inject DOM by using the animation `selector`, and then
 * ```typescript
 * switch (stage) {
 *    case TS_INIT:
 *      const adapters = args.scene.getElementAdapters(anime.selector);
 *      elAdapters.forEach((elAdapter, elIndex) => {
 *        const html = elAdapter.getProp('html', args);
 *        const myPiece = '<div>Hello</div>';
 *        elAdapter.setProp('html', html + myPiece, args);
 *      });
 * }
 * ```
 *
 * - inject animation properties into the pipeline by:
 * ```typescript
 * switch (stage) {
 *    case TS_INIT:
 *      anime.props.push({ prop: 'text', value: ['hello'] });
 * }
 * ```
 */
var ABeamer;
(function (ABeamer) {
    // #generate-group-section
    // ------------------------------------------------------------------------
    //                               Tasks
    // ------------------------------------------------------------------------
    // The following section contains data for the end-user
    // generated by `gulp build-definition-files`
    // -------------------------------
    // #export-section-start: release
    // ------------------------------------------------------------------------
    //                               Task Results
    // ------------------------------------------------------------------------
    ABeamer.TR_EXIT = 0;
    ABeamer.TR_DONE = 1;
    ABeamer.TR_INTERACTIVE = 2;
    // ------------------------------------------------------------------------
    //                               Task Stage
    // ------------------------------------------------------------------------
    ABeamer.TS_INIT = 0;
    ABeamer.TS_ANIME_LOOP = 1;
    ABeamer.TS_TELEPORT = 2;
    // #export-section-end: release
    // -------------------------------
    // ------------------------------------------------------------------------
    //                               Implementation
    // ------------------------------------------------------------------------
    /** Map of the built-in path tasks, plus the ones added via plugins. */
    ABeamer._taskFunctions = {};
    function _buildWorkTask(task, anime, toTeleport, args) {
        var handler = task.handler;
        var taskFunc;
        args.user = task.params;
        switch (typeof handler) {
            case 'string':
                taskFunc = ABeamer._taskFunctions[handler];
                break;
            case 'function':
                taskFunc = handler;
                ABeamer.throwIfI8n(toTeleport, ABeamer.Msgs.NoCode);
                break;
        }
        if (!taskFunc) {
            ABeamer.throwI8n(ABeamer.Msgs.UnknownOf, { type: ABeamer.Msgs.task, p: handler });
        }
        var wkTask = {
            func: taskFunc,
            name: handler,
            params: task.params || {},
            animeIndex: -1,
        };
        if (toTeleport) {
            task.handler = handler;
            taskFunc(anime, wkTask, wkTask.params, ABeamer.TS_TELEPORT, args);
        }
        return wkTask;
    }
    /**
     * Converts the Handlers into strings, and calls tasks on TELEPORT stage.
     */
    function _prepareTasksForTeleporting(anime, tasks, args) {
        tasks.forEach(function (task) { _buildWorkTask(task, anime, true, args); });
    }
    ABeamer._prepareTasksForTeleporting = _prepareTasksForTeleporting;
    /**
     * If it returns true, this Animation is full processed
     * and the animation should be bypassed.
     */
    function _processTasks(tasks, wkTasks, anime, args) {
        var toExit = true;
        tasks.forEach(function (task) {
            var wkTask = _buildWorkTask(task, anime, false, args);
            var taskResult = wkTask.func(anime, wkTask, wkTask.params, ABeamer.TS_INIT, args);
            switch (taskResult) {
                case ABeamer.TR_EXIT: return;
                case ABeamer.TR_DONE:
                    toExit = false;
                    break;
                case ABeamer.TR_INTERACTIVE:
                    toExit = false;
                    wkTasks.push(wkTask);
                    break;
            }
        });
        return toExit;
    }
    ABeamer._processTasks = _processTasks;
    function _runTasks(wkTasks, anime, animeIndex, args) {
        wkTasks.forEach(function (wkTask) {
            wkTask.animeIndex = animeIndex;
            wkTask.func(anime, wkTask, wkTask.params, ABeamer.TS_ANIME_LOOP, args);
        });
    }
    ABeamer._runTasks = _runTasks;
    // ------------------------------------------------------------------------
    //                               factory Task
    // ------------------------------------------------------------------------
    function _formatValue(value, isFormatted, index, args) {
        if (typeof value === 'object') {
            value = value[index % value.length];
        }
        if (isFormatted === false) {
            return value;
        }
        args.vars.i = index;
        var exprValue = ABeamer.ifExprCalc(value, args);
        return exprValue !== undefined ? exprValue.toString() :
            ABeamer.sprintf(value, index);
    }
    ABeamer._taskFunctions['factory'] = _factory;
    /** Implements the Factory Task */
    function _factory(anime, _wkTask, params, stage, args) {
        switch (stage) {
            case ABeamer.TS_INIT:
                var tag_1 = params.tag || 'div';
                var count_1 = ABeamer.ifExprCalcNum(params.count, params.count, args);
                var needsClosing_1 = ['img'].indexOf(tag_1) === -1;
                var elAdapters = args.scene.getElementAdapters(anime.selector);
                args.vars.elCount = elAdapters.length;
                elAdapters.forEach(function (elAdapter, elIndex) {
                    args.vars.elIndex = elIndex;
                    var inTextHtml = [];
                    var _loop_1 = function (i) {
                        var parts = ['<' + tag_1];
                        (params.attrs || []).forEach(function (param) {
                            var value = _formatValue(param.value, param.isFormatted, i, args);
                            parts.push(" ".concat(param.name, "=\"").concat(value, "\""));
                        });
                        parts.push('>');
                        parts.push(_formatValue(params.content || '', params.isContentFormatted, i, args));
                        if (needsClosing_1) {
                            parts.push("</".concat(tag_1, ">"));
                        }
                        inTextHtml.push(parts.join(''));
                    };
                    for (var i = 0; i < count_1; i++) {
                        _loop_1(i);
                    }
                    elAdapter.setProp('html', inTextHtml.join('\n'), args);
                });
                return ABeamer.TR_EXIT;
        }
    }
})(ABeamer || (ABeamer = {}));
//# sourceMappingURL=tasks.js.map