"use strict";
// ------------------------------------------------------------------------
// Copyright (c) 2018-2024 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License.
// ------------------------------------------------------------------------

// Parses and computes a simulation of CSS animation-direction

/** @module end-user | The lines bellow convey information for the end-user */

/**
 * ## Description
 *
 * ABeamer implements the animation direction in a similar way of the
 * CSS `animation-direction` property.
 * Currently is supported: `normal`, `reverse`, `alternate`, `alternate-reverse`
 *
 * The value is defined per property.
 * Both textual and numeric values are supported.
 *
 * Use `iterationCount` to repeat the cycle.
 * To ensure that `normal` and `reverse` finish their cycles at the same time,
 * the `reverse` repeats the same value at the beginning of the next cycle.
 *
 * @see gallery/animate-loop
 */
namespace ABeamer {

  // #generate-group-section
  // ------------------------------------------------------------------------
  //                               Animation Direction
  // ------------------------------------------------------------------------

  // The following section contains data for the end-user
  // generated by `gulp build-definition-files`
  // -------------------------------
  // #export-section-start: release

  export enum Directions {
    normal,
    reverse,
    alternate,
    'alternate-reverse',
  }

  // #export-section-end: release
  // -------------------------------

  // ------------------------------------------------------------------------
  //                               Implementation
  // ------------------------------------------------------------------------

  type Dir = 1 | -1;
  export type _DirPair = [Dir, Dir];

  const DIRECTION_TO_DIR_PAIR = [[1, 1], [-1, -1], [1, -1],
  [-1, 1]] as [Dir, Dir][];


  export function _propDirToDirPair(
    direction: uint | string | undefined): _DirPair {

    if (direction === undefined) {
      return DIRECTION_TO_DIR_PAIR[Directions.normal];
    }

    if (typeof direction === 'string') {
      direction = Directions[direction];
    }

    if (direction < 0 || direction >= DIRECTION_TO_DIR_PAIR.length) {
      throwErr(`Direction has an invalid value`);
    }

    return DIRECTION_TO_DIR_PAIR[direction as uint];
  }

  // ------------------------------------------------------------------------
  //                               Compute
  // ------------------------------------------------------------------------

  export function _computeIterationCount(i, frameI: uint,
    dirPair: _DirPair, framesPerCycle: uint): uint {

    // ensures that if reach the end of the cycle and needs to alternate,
    // one extra frame will be on the same position
    if (dirPair[0] !== dirPair[1] &&
      ((i + 1) % framesPerCycle === 0)) {
      return frameI;
    }

    const isOddInt = Math.floor((i + 1) / framesPerCycle) % 2;
    frameI += dirPair[isOddInt];
    if (frameI >= framesPerCycle) {
      frameI -= framesPerCycle;
    } else if (frameI < 0) {
      frameI += framesPerCycle;
    }

    return frameI;
  }
}
