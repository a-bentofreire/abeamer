"use strict";
// ------------------------------------------------------------------------
// Copyright (c) 2018-2024 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License.
// ------------------------------------------------------------------------
/** @module internal | This module is to be read only by developers */
/**
 * ## Description
 *
 * An **action** is an internal representation of how a property value
 * of an element will change in a specific frame.
 * Actions are the resulting tree of the `scene.addAnimations`,
 * which transform user defined animations into frames.
 * Each frame which contain `_ElActions` and each `_ElActions` contain
 * a list of `_Actions`.
 *
 * **ActionRg** is used to monitor what was the previous value of a property,
 * and each frames it can bypassed.
 */
var ABeamer;
(function (ABeamer) {
    // ------------------------------------------------------------------------
    //                               Actions
    // ------------------------------------------------------------------------
    /**
     * Finds the previous `actionRg`, generated by a previous `addAnimation`.
     * If it exists, it links to the previous `actionRg` to a newly created `actionRg`,
     * If doesn't exist just creates a `actionRg`.
     *
     * `_findActionRg` uses `elementAdpt.getProp('uid', args)` to determine if has already
     * an ActionRg.
     */
    function _findActionRg(actionRgMaps, elementAdpt, propName, startFrame, endFrame, args) {
        var propValue = elementAdpt.getProp('uid', args);
        var index = propValue !== undefined ? parseInt(propValue) : -1;
        var found = index >= 0;
        var actionRgMap;
        if (!found) {
            index = actionRgMaps.length;
            elementAdpt.setProp('uid', index.toString(), args);
            actionRgMap = {};
            actionRgMaps.push(actionRgMap);
        }
        else {
            actionRgMap = actionRgMaps[index];
        }
        var actionRgList = actionRgMap[propName];
        if (!actionRgList) {
            actionRgList = [];
            actionRgMap[propName] = actionRgList;
        }
        var actionRg = {
            startFrame: startFrame,
            endFrame: endFrame,
        };
        actionRgList.push(actionRg);
        var res = {
            actionRgMap: actionRgMap,
            actionRgList: actionRgList,
            actionRg: actionRg,
            linkIndex: actionRgList.length - 2,
        };
        if (res.linkIndex >= 0) {
            var lastActionRg = actionRgList[res.linkIndex];
            actionRg.propType = lastActionRg.propType;
            if (lastActionRg.endFrame >= startFrame) {
                ABeamer.throwErr("overlapping property animations is not supported." +
                    "".concat(lastActionRg.endFrame, " must be higher than ").concat(startFrame));
            }
        }
        return res;
    }
    ABeamer._findActionRg = _findActionRg;
})(ABeamer || (ABeamer = {}));
//# sourceMappingURL=actions.js.map