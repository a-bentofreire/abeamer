"use strict";
// ------------------------------------------------------------------------
// Copyright (c) 2018-2024 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License.
// ------------------------------------------------------------------------

/** @module end-user | The lines bellow convey information for the end-user */

/**
 *
 * ## Description
 *
 * A **plugin** is a 3rd-party extension which provides a set of functionalities,
 * allowing to extend the ecosystem to the already rich set of built-in functionalities.
 *
 * Plugins creators who wish to create a plugin to support [](teleporter), must:
 *
 * - Declare the plugin via `pluginManager.addPlugin`.
 * - Set the `pluginInfo.teleportable = true`.
 * - Follow the [Developer Guideline Rules](../../../../../developer/dev-docs/coding-style).
 *
 * ABeamer allows plugins to add the following functionality types:
 *
 * - [](easings)
 * - [](oscillators)
 * - [](paths)
 * - [](tasks)
 * - [](transitions)
 * - [](flyovers)
 * - [](functions)
 * - [](i18n)
 *
 * To add a functionality use: `pluginManager.add<functionality-type>`.
 *
 * In most cases, a functionality is a function that receives a set of parameters
 * followed by `args?:ABeamerArgs`.
 * This last parameter will provide information regarding the state of the system.
 *
 * Plugins should try to be independent of DOM in order to work
 * with virtual elements such as WebGL and canvas. However, in some cases is
 * required to work with DOM only.
 */
namespace ABeamer {

  // #generate-group-section
  // ------------------------------------------------------------------------
  //                               Plugin Manager
  // ------------------------------------------------------------------------

  // The following section contains data for the end-user
  // generated by `gulp build-definition-files`
  // -------------------------------
  // #export-section-start: release

  export interface AnyParams { [key: string]: any; }

  export interface ABeamerArgs {
    story?: Story;
    scene?: Scene;
    stage?: uint;
    /** Every time, the render is executed this value is incremented. */
    renderNr?: uint;
    user?: AnyParams;
    waitMan?: WaitMan;
    /** If true, the internal code or plugin should dump information using `story.logFrmt`. */
    isVerbose?: boolean;
    /**
     * True if it's running a supporting server program for frame storage.
     *
     * #end-user @readonly
     */
    hasServer?: boolean;
    isTeleporting?: boolean;
    /** If true, perform type checks and other restriction checks. */
    isStrict?: boolean;

    /*
     * Global variables used as variables of expressions.
     * `abeamer render` command-line can change these variables by passing them
     * as multiple `--var` parameters,
     * these parameters will be converted to queryString and added to url.
     *
     * ## Examples
     *
     * accessed by expressions in client library:
     * `valueText: 'pi*2'`
     *
     * passed by command line:
     * `abeamer render --var name=end-user --var value=1.2.3`.
     *
     * passed on the url:
     * ?var=name%3Dend-user&var=value%3D1.2.3
     */
    vars: Vars;
  }


  /**
   * Information required by each plugin creator about its own plug-in.
   */
  export interface PluginInfo {
    id: string;
    uuid: string;
    author: string;
    email: string;
    copyrights?: string;
    jsUrls?: string[];
    cssUrls?: string[];
    assetsUrls?: string[];
    telemetricUrl?: string[];
    teleportable: boolean;
  }


  /** List of all the functionalities available to be extended by plugins. */
  export enum Functionalities {
    easings,
    oscillators,
    paths,
    transitions,
    tasks,
    flyovers,
    functions,
  }

  // #export-section-end: release
  // -------------------------------

  const _FunctionalitiesContainers = [
    _easingFunctions,
    _easingFunctions,
    _pathFunctions,
    _taskFunctions,
    _transitionFunctions,
    _flyoverFunctions,
    _exFunctions,
  ];


  /**
   * Allows 3rd-party to add easings, oscillators, paths, etc.
   */
  export class _PluginManager implements PluginManager {

    _plugins: PluginInfo[] = [];
    _locale: string = 'en';


    addPlugin(pluginInfo: PluginInfo): void {
      this._plugins.push(pluginInfo);
    }


    addEasings(easings: [string, EasingFunc][]): void {
      easings.forEach(easing => {
        _easingFunctions[easing[0]] = easing[1];
      });
    }


    addOscillators(oscillators: [string, OscillatorFunc][]): void {
      oscillators.forEach(oscillator => {
        _easingFunctions[oscillator[0]] = oscillator[1];
      });
    }


    addPaths(paths: [string, PathFunc][]): void {
      paths.forEach(path => {
        _pathFunctions[path[0]] = path[1];
      });
    }


    addTasks(tasks: [string, TaskFunc][]): void {
      tasks.forEach(task => {
        _taskFunctions[task[0]] = task[1];
      });
    }


    addTransitions(transitions: [string, TransitionFunc][]): void {
      transitions.forEach(transition => {
        _transitionFunctions[transition[0]] = transition[1];
      });
    }


    addFlyovers(flyovers: [string, FlyoverFunc][]): void {
      flyovers.forEach(flyover => {
        _flyoverFunctions[flyover[0]] = flyover[1];
      });
    }


    addFunctions(functions: [string, ExFunction][]): void {
      functions.forEach(exprFunction => {
        _exFunctions[exprFunction[0]] = exprFunction[1];
      });
    }


    addLocalization(localeInfo: Localization): void {

      this._locale = localeInfo.locale;
      if (!this._locale) {
        throwErr('The localization locale can not be empty');
      }

      if (localeInfo.charRanges) {
        localeInfo.charRanges.forEach(charRange => {
          CharRanges.push(charRange);
        });
      }

      const msgs = localeInfo.messages;
      if (msgs) {
        Object.keys(msgs).forEach(srcMsg => {
          Msgs[srcMsg] = msgs[srcMsg];
        });
      }

      if (localeInfo.functionalities) {
        localeInfo.functionalities.forEach(functionality => {

          const [aType, map] = functionality;
          const funcIndex = typeof aType === 'string' ? Functionalities[aType] : aType;
          if (funcIndex === undefined) {
            throw `Unknown functionality ${aType}`;
          }
          const container = _FunctionalitiesContainers[funcIndex];
          map.forEach(srcDst => {
            container[srcDst.dst] = container[srcDst.src];
          });
        });
      }
    }
  }

  export const pluginManager = new _PluginManager();
}
