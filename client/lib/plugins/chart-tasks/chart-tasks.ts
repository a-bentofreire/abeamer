"use strict";
// ------------------------------------------------------------------------
// Copyright (c) 2018-2024 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License.
// ------------------------------------------------------------------------

// Implements a list of built-in chart Tasks

/** @module end-user | The lines bellow convey information for the end-user */

/**
 * ## Description
 *
 * A **chart** task creates an animated chart.
 *
 * **WARN** This plugin is still in development stage, parts of API can change in the future.
 * However is already in a stage that can be used.
 *
 * This plugin has the following built-in charts:
 *
 * - [pie](#PieChartTaskParams)
 * - [bar](#AxisChartTaskParams)
 * - [area](#AxisChartTaskParams)
 * - [line](#AxisChartTaskParams)
 * - [marker](#AxisChartTaskParams)
 * - [mixed](#AxisChartTaskParams) Draws different types of chars in the same chart, uses
 *   [](#chartTypes) parameter to determine the type of each chart per series.
 *
 * read the details on [](#AxisChartTaskParams).
 *
 * ## Get started
 * How to create a simple bar chart:
 *
 * The bare-bones of a `abeamer.ini` file:
 * ```scss
 * $abeamer-width: 300;
 * $abeamer-height: 150;
 * ```
 *
 *  The bare-bones of a `html` file:
 * ```html
 * <div class="abeamer-story" id=story>
 *     <div class=abeamer-scene id=scene1>
 *       <canvas id=chart width=300 height=150></canvas>
 *     </div>
 * </div>
 * ```
 *
 * On the `hello-world` example, replace the `scene.addAnimations` with:
 * ```typescript
 * scene.addAnimations([{
 *    selector: '#chart', // JQuery selector pointing to the HtmlElement
 *    tasks: [{
 *      handler: 'chart', // is always 'chart' for charts.
 *      params: {
 *        chartType: ABeamer.ChartTypes.bar, // or 'bar' if you are using javascript
 *        labelsX: { captions: ['A', 'B', 'C', 'D', 'E'] },
 *        title: 'My first Chart',
 *        data: [[100, 200, 50, 140, 300]],
 *      } as ABeamer.AxisChartTaskParams, // comment as ... if you are using javascript
 *    }],
 *  }]);
 * ```
 * The previous example, will create a static chart.
 * To animate it, change it the to following:
 * ```typescript
 *  scene.addAnimations([{
 *   selector: 'canvas',
 *   tasks: [{
 *     handler: 'chart',
 *     params: {
 *       chartType: ABeamer.ChartTypes.bar,
 *       labelsX: { captions: ['A', 'B', 'C', 'D', 'E'] },
 *       title: 'My first Chart',
 *       data: [[100, 200, 50, 140, 300]],
 *       // animation parameters
 *       pointHeightStart: 0.1,    // defined the initial value for the animation point-height property
 *       animeSelector: 'chart-anime-01', // unique animation selector to be used by the animator
 *     } as ABeamer.AxisChartTaskParams,
 *   }],
 * }])
 *   .addAnimations([{
 *     selector: `%chart-anime-01`, // animation selector defined previously, prefixed with '%'
 *     duration: `1s`,
 *     props: [{
 *       prop: 'point-height', // property which initial value is 0.1
 *       value: 1,             // value at the end of animation
 *     }],
 *   }]);
 * ```
 */
namespace ABeamer {

  // #generate-group-section
  // ------------------------------------------------------------------------
  //                               Chart Tasks
  // ------------------------------------------------------------------------

  // The following section contains data for the end-user
  // generated by `gulp build-definition-files`
  // -------------------------------
  // #export-section-start: release

  export enum ChartTypes {
    pie,
    bar,
    area,
    line,
    marker,
    mixed,
  }

  export type ChartTaskName = 'chart';


  export interface ExprSeries {
    /**
     * Expression that defines the series.
     * `v` is the variable that starts in `startValue`, increments `step`.
     * `n` is the number of points.
     */
    expr: ExprString;
    /**
     * Number of points generated by the expr.
     * If it's undefined, but there is already a previous series it will use
     * the previous series nrPoints.
     * @default ChartDefaults.nrPoints
     */
    nrPoints: uint;
    startValue?: number;
    step?: number;
  }


  export type SeriesData = number[] | ExprSeries;


  export enum ChartCaptionOrientation {
    horizontal,
    vertical,
  }


  export enum ChartCaptionPosition {
    top,
    bottom,
    left,
    right,
  }


  export enum ChartCaptionAlignment {
    left,
    center,
    right,
  }


  export interface ChartCaptions {
    fontColor?: string | ExprString;
    fontFamily?: string | ExprString;
    fontSize?: uint | ExprString;
    alignment?: ChartCaptionAlignment | string;
    position?: ChartCaptionPosition | string;
    orientation?: ChartCaptionOrientation | string;
    marginBefore?: uint | ExprString;
    marginAfter?: uint | ExprString;
  }


  export interface ChartLabels extends ChartCaptions {
    captions?: string[] | ExprString;
  }


  export type ChartLabelsX = ChartLabels;


  export interface ChartLegendMark {
    width?: uint | ExprString;
    height?: uint | ExprString;
    spacing?: uint | ExprString;
  }


  export interface ChartLegend extends ChartLabels {
    mark?: ChartLegendMark;
  }


  export interface ChartLabelsY extends ChartLabels {
    tickCount?: uint;
  }


  export enum ChartPointShape {
    circle,
    square,
    diamond,
  }


  export interface ChartMarkers {
    visible?: boolean | boolean[] | boolean[][];
    shape?: (ChartPointShape | string) | (ChartPointShape | string)[]
    | (ChartPointShape | string)[][];
    size?: uint | uint[] | uint[][];
    color?: string | string[] | string[][];
  }


  export interface ChartLine {
    visible?: boolean;
    color?: string | ExprString;
    width?: number | ExprString;
  }


  export interface ChartTitle extends ChartCaptions {
    caption: string | ExprString;
  }


  export interface ChartDefaults {
    labelsX: ChartLabelsX;
    labelsY: ChartLabelsY;
    legend: ChartLegend;
    title: ChartTitle;
    fillColors: string;
    strokeColors: string;
    strokeWidth: uint;
    markers: ChartMarkers;
    barWidth: uint;
    pointMaxHeight: uint;
    pointDistance: uint;
    seriesSpacing: uint;
    /** Number of Points for ExprSeries */
    nrPoints: uint;
  }


  /**
   * Parameters for both [Axis Charts](#AxisChartTaskParams) and [Pie Charts](#PieChartTaskParams).
   */
  export interface BaseChartTaskParams extends AnyParams {
    /**
     * Defines the type of chart.
     * If it's `mixed` it uses [](#chartTypes)
     */
    chartType?: ChartTypes | string;


    /**
     * List of series of data points.
     * Each series much have the same number of data points.
     */
    data: SeriesData[];

    /**
     * Set with a unique virtual selector, to be used another `addAnimations` to animate the chart.
     * ### Example
     * ```typescript
     *    scene.addAnimations([{
     *     selector: 'canvas',
     *     tasks: [{
     *       handler: 'chart',
     *       params: {
     *         data: [[100, 200, 50, 140, 300]],
     *         pointHeightStart: 0.1,    // defined the initial value for the animation point-height property
     *         animeSelector: 'chart-anime-02', // unique animation selector to be used by the animator
     *       } as ABeamer.AxisChartTaskParams,
     *     }],
     *   }])
     *     .addAnimations([{
     *       selector: `%chart-anime-02`, // animation selector defined previously, prefixed with '%'
     *       duration: `1s`,
     *       props: [{
     *         prop: 'point-height', // property which initial value is 0.1
     *         value: 1,             // value at the end of animation
     *       }],
     *     }]);
     * ```
     */
    animeSelector?: string;


    /**
     * Defines the chart title.
     * At the moment is only supported horizontal top or bottom titles.
     */
    title?: string | ExprString | ChartTitle;


    /**
     * Defines the chart legend.
     * At the moment is only supported stacked left or right top legend.
     */
    legend?: ChartLegend;


    // colors
    /** Interior Color used by `area`, `bar` and `pie` charts. */
    fillColors?: string | string[] | string[][];
    /** Outline Color used by `area`, `bar` and `pie` charts, and line color for `line` chart. */
    strokeColors?: string | string[] | string[][];
    strokeWidth?: uint | uint[] | uint[][];
  }


  /**
   * Parameters used by Pie Charts.
   * Pie Charts provide the following animators:
   * - [angle](#PieChartTaskParams.angleStart) with initial value in angleStart.
   * - [dispersion](#PieChartTaskParams.dispersionStart) with initial value in dispersionStart.
   */
  export interface PieChartTaskParams extends BaseChartTaskParams {
    /**
     * Initial angle in radians defining the zero radial line of the chart.
     * This parameter is animated with property `angle`.
     */
    angleStart?: number | ExprString;


    /**
     * Initial dispersion factor defined between 0 and 1.
     * A dispersion defines the percentage of how much the pie circle will be used.
     * A value of 1 represents a full circle, and a value of 0.5, represents half circle.
     * This parameter is animated with property `dispersion`.
     */
    dispersionStart?: number | ExprString;
    isClockwise?: boolean;
  }


  /**
   * Parameters used by Axis Charts, which are all except [Pie Charts](#PieChartTaskParams).
   * Axis Charts provide the following animators:
   * - [point-height](#AxisChartTaskParams.pointHeightStart) with initial value in pointHeightStart.
   * - [deviation](#AxisChartTaskParams.deviationStart) with initial value in deviationStart.
   * - [sweep](#AxisChartTaskParams.sweepStart) with initial value in sweepStart.
   */
  export interface AxisChartTaskParams extends BaseChartTaskParams {

    /**
     * Chart Type per series. Use only if [](#chartType) is `mixed`.
     * @example: [ABeamer.ChartTypes.bar, ABeamer.ChartTypes.bar, ABeamer.ChartTypes.line]
     */
    chartTypes?: (ChartTypes | string)[];


    /**
     * Defines the X labels with complete information or just as an [](#ExprString).
     * If it's a ExprString, it will create one label for each point.
     * The iterator variable is `v`.
     * If it's an array, it must match the number of points in a series.
     * @example =2012 + v
     * @example { captions: ['A', 'B', 'C', 'D'] }
     */
    labelsX?: ChartLabelsX | ExprString | string[];


    /**
     * Defines the Y labels with complete information or just as an [](#ExprString).
     * If it's a ExprString, it will create one label for each point.
     * The iterator variable is `v`.
     * If it's an array, it must match the tickCount.
     * @example =v/1000 + 'k'
     * @example { captions: ['10', '20', '30', '40'] }
     */
    labelsY?: ChartLabelsY | ExprString | string[];


    // markers
    markers?: ChartMarkers;


    /**
     * x bar length for `bar` charts.
     * If it's zero, it's calculated automatically in order to fill the complete x-space.
     */
    barWidth?: uint | ExprString;


    // points
    pointMaxHeight?: uint | ExprString;


    /**
     * x distance between two data points.
     * If it's zero, it's calculated automatically in order to fill the complete x-space.
     * If the chart includes bars charts it must be big enough to include all the bars.
     */
    pointDistance?: uint | ExprString;


    /**
     * x space between two bars. Used only in `bar` charts.
     */
    seriesSpacing?: uint | ExprString;


    // colors
    /**
     * Colors to be used in case of the data point is negative.
     * At the moment, it only supports `bar` charts.
     */
    negativeFillColors?: string | string[] | string[][];


    xAxis?: ChartLine;
    yAxis?: ChartLine;
    y0Line?: ChartLine;


    // limits
    maxValue?: number | ExprString;
    minValue?: number | ExprString;


    // animation
    pointHeightStart?: number | ExprString;
    deviationStart?: number | ExprString;
    sweepStart?: number | ExprString;
  }


  // #export-section-end: release
  // -------------------------------

  // ------------------------------------------------------------------------
  //                               Implementation
  // ------------------------------------------------------------------------

  pluginManager.addPlugin({
    id: 'abeamer.chart-tasks',
    uuid: '73631f28-df71-4b4d-88e1-c99a858e0fd3',
    author: 'Alexandre Bento Freire',
    email: 'abeamer@a-bentofreire.com',
    jsUrls: ['plugins/chart-tasks/chart-tasks.js'],
    teleportable: true,
  });


  const _defValues = getVars()['chart'] = {
    labelsX: {
      fontFamily: 'sans-serif',
      fontColor: 'black',
      fontSize: 12,
      alignment: ChartCaptionAlignment.center,
      position: ChartCaptionPosition.bottom,
      orientation: ChartCaptionOrientation.horizontal,
      marginBefore: 0,
      marginAfter: 0,
    },

    labelsY: {
      fontFamily: 'sans-serif',
      fontColor: 'black',
      fontSize: 12,
      alignment: ChartCaptionAlignment.right,
      position: ChartCaptionPosition.left,
      orientation: ChartCaptionOrientation.horizontal,
      marginBefore: 0,
      marginAfter: 5,
      tickCount: 6,
    },

    legend: {
      fontFamily: 'sans-serif',
      fontColor: 'black',
      fontSize: 12,
      alignment: ChartCaptionAlignment.left,
      position: ChartCaptionPosition.right,
      orientation: ChartCaptionOrientation.horizontal,
      marginBefore: 0,
      marginAfter: 5,
      mark: {
        width: 10,
        height: 3,
        spacing: 4,
      },
    },

    title: {
      fontFamily: 'sans-serif',
      fontColor: 'black',
      fontSize: 14,
      alignment: ChartCaptionAlignment.center,
      position: ChartCaptionPosition.top,
      orientation: ChartCaptionOrientation.horizontal,
      marginBefore: 0,
      marginAfter: 0,
    },

    fillColors: '#ffecad',
    strokeColors: '#101010',
    strokeWidth: 1,
    markers: {
      shape: ChartPointShape.square,
      size: 5,
      color: 'black',
    },
    barWidth: 0,
    pointMaxHeight: 100,
    pointDistance: 0,
    seriesSpacing: 3,
    nrPoints: 10,
  } as ChartDefaults;


  /**
   * Returns the maximum value of array of array of numbers.
   */
  function _maxOfArrayArray(data: number[][], startValue: number): number {
    data.forEach(series => {
      series.forEach(point => {
        startValue = Math.max(startValue, point);
      });
    });
    return startValue;
  }

  // ------------------------------------------------------------------------
  //                               _ChartVirtualAnimator
  // ------------------------------------------------------------------------

  class _ChartVirtualAnimator extends SimpleVirtualAnimator implements VirtualAnimator {

    charts: _WkChart[] = [];
    params: BaseChartTaskParams;

    animateProps(): void {
      this.charts.forEach(chart => {
        chart._drawChart(this.params);
      });
    }
  }

  // ------------------------------------------------------------------------
  //                               Captions
  // ------------------------------------------------------------------------

  interface _WkChartCaptions {
    fontColor?: string;
    fontFamily?: string;
    fontSize?: uint;
    marginBefore?: uint;
    marginAfter?: uint;
    alignment?: ChartCaptionAlignment;
    orientation?: uint;
    position?: uint;
    width?: uint;
    height?: uint;
    x?: uint;
    y?: uint;
  }


  function _setUpCaptionsFont(l: _WkChartCaptions,
    ctx: CanvasRenderingContext2D): void {

    ctx.font = `${l.fontSize}px ${l.fontFamily}`;
    ctx.fillStyle = l.fontColor;
    ctx.textBaseline = 'bottom';
  }

  // ------------------------------------------------------------------------
  //                               Labels
  // ------------------------------------------------------------------------

  interface _WkChartLabels extends _WkChartCaptions {
    captions?: string[];
  }


  function _ExprStrToLabels<T extends ChartLabels>(l: T | ExprString | string[]): T {
    switch (typeof l) {
      case 'undefined': return {} as T;
      case 'string': return { captions: l as string } as T;
      default:
        return l as T;
    }
  }

  export let testDiv: HTMLDivElement;

  function _alignCaptions(l: _WkChartCaptions, ctx: CanvasRenderingContext2D,
    text: string, width: uint): uint {

    if (l.alignment === ChartCaptionAlignment.left) {
      return 0;
    }
    // let style: CSSStyleDeclaration;
    // if (!testDiv) {
    //   testDiv = document.createElement('div');
    //   style = testDiv.style;
    //   style.position = 'absolute';
    //   style.top = '0px';
    //   style.left = '0px';
    //   style.width = '1px';
    //   style.height = '0px';
    //   document.body.appendChild(testDiv);
    // }

    // style = testDiv.style;
    // style.display = 'inline-block';
    // style.fontFamily = l.fontFamily;
    // style.fontSize = l.fontSize + 'px';
    // testDiv.textContent = text;

    // style.display = 'none';

    // @TODO: Implement a better way to compute the text height
    const sz = ctx.measureText(text);
    switch (l.alignment) {
      case ChartCaptionAlignment.center:
        return (width - sz.width) / 2;
      case ChartCaptionAlignment.right:
        return (width - sz.width);
    }
    return 0;
  }

  // ------------------------------------------------------------------------
  //                               Line
  // ------------------------------------------------------------------------

  interface _WkChartLine {
    visible: boolean;
    color: string;
    width: number;
  }

  // ------------------------------------------------------------------------
  //                               Points
  // ------------------------------------------------------------------------

  interface _WkChartTitle extends _WkChartCaptions {
    caption?: string;
  }

  // ------------------------------------------------------------------------
  //                               Markers
  // ------------------------------------------------------------------------

  interface _WkChartMarkers {
    visible?: boolean[][];
    shape?: ChartPointShape[][];
    size?: uint[][];
    color?: string[][];
  }

  // ------------------------------------------------------------------------
  //                               Legend
  // ------------------------------------------------------------------------

  interface _WkChartLegendMark {
    width: uint;
    height: uint;
    spacing: uint;
  }


  interface _WkChartLegend extends _WkChartCaptions {
    captions?: string[];
    mark?: _WkChartLegendMark;
  }

  // ------------------------------------------------------------------------
  //                               _WkChart
  // ------------------------------------------------------------------------

  type _WkSeriesData = number[];

  abstract class _WkChart {

    protected props: AnyParams;
    protected canvas: HTMLCanvasElement;
    protected context: CanvasRenderingContext2D;
    protected chartWidth: uint;
    protected chartHeight: uint;

    protected chartType: ChartTypes;
    protected min: number;
    protected max: number;
    protected sum: number;
    protected avg: number;
    protected nrPoints: uint;
    protected data: _WkSeriesData[];

    protected animator: _ChartVirtualAnimator;

    // title
    protected title: _WkChartTitle = {};

    // legends
    protected legend: _WkChartLegend = {};

    // colors
    fillColors: string[][];
    strokeColors: string[][];
    strokeWidth: uint[][];

    // overflow
    overflow: uint = 0;

    // graph  (x0, y0) = (left, bottom)
    graphX0: uint = 0;
    graphY0: uint;
    graphX1: uint;
    graphY1: uint = 0;

    constructor(protected args: ABeamerArgs) { }

    _drawChart(_params: BaseChartTaskParams): void {
      this._drawLegend();
    }


    protected _fillArrayArrayParam<TI, TO>(param: TI | TI[] | TI[][],
      defValue: TI, strMapper?: any): TO[][] {

      const res: TO[][] = [];

      if (param === undefined) {
        param = defValue;
      }

      const isParamArray = Array.isArray(param);
      if (!isParamArray && strMapper && typeof param === 'string') {
        param = strMapper[param];
      }

      this.data.forEach((series, seriesI) => {
        let resItem = [];
        if (!isParamArray) {
          resItem = series.map(_v => param);
        } else {

          let subParam = param[seriesI];
          const isSubParamArray = Array.isArray(subParam);
          if (!isSubParamArray && strMapper && typeof subParam === 'string') {
            subParam = strMapper[subParam];
          }

          if (!isSubParamArray) {
            resItem = series.map(_v => subParam);
          } else {
            resItem = series.map((_v, i) => {
              let itemParam = subParam[i];
              if (strMapper && typeof itemParam === 'string') {
                itemParam = strMapper[itemParam];
              }
              return itemParam;
            });
          }
        }
        res.push(resItem);
      });
      return res;
    }


    _initChart(params: BaseChartTaskParams): void {
      // colors

      this.fillColors = this._fillArrayArrayParam(params.fillColors,
        _defValues.fillColors);
      this.strokeColors = this._fillArrayArrayParam(params.strokeColors,
        _defValues.strokeColors);
      this.strokeWidth = this._fillArrayArrayParam(params.strokeWidth,
        _defValues.strokeWidth);

      this.overflow = _maxOfArrayArray(this.strokeWidth, this.overflow);

      this.graphX1 = this.chartWidth;
      this.graphY0 = this.chartHeight;
      this._initTitle(params);
      this._initLegend(params);
    }


    _init(elAdapter: ElementAdapter, chartType: ChartTypes,
      animator: _ChartVirtualAnimator | undefined): void {

      this.canvas = elAdapter.getProp('element', this.args) as any;
      if (!this.canvas) {
        throwErr(`Didn't find the ${elAdapter.getId()}`);
      }

      this.context = this.canvas.getContext('2d');
      this.chartWidth = this.canvas.width;
      this.chartHeight = this.canvas.height;
      this.chartType = chartType;
      this.animator = animator;
      this.props = animator ? animator.props : {};
    }


    _initData(data: SeriesData[]): void {
      let max = -Number.MIN_VALUE;
      let min = Number.MAX_VALUE;
      let sum = 0;
      let nrPoints;
      this.data = data.map((series, seriesI) => {
        let res: _WkSeriesData;
        if (Array.isArray(series)) {
          res = series as _WkSeriesData;
        } else {
          res = [];
          const exprSeries = series as ExprSeries;
          const v0 = exprSeries.startValue || 0;
          const step = exprSeries.step || 1;
          const nrPts = exprSeries.nrPoints || nrPoints || _defValues.nrPoints;
          this.args.vars.n = nrPts;
          for (let i = 0; i < nrPts; i++) {
            this.args.vars.v = i * step + v0;
            const v1 = calcExpr(exprSeries.expr, this.args);
            res.push(typeof v1 === 'number' ? v1 : parseFloat(v1 as string));
          }
        }
        if (!seriesI) {
          nrPoints = res.length;
        } else {
          if (res.length !== nrPoints) {
            throwErr(`Every Series must have the same number of points`);
          }
        }
        return res;
      });

      this.data.forEach(series => {
        series.forEach(point => {
          max = Math.max(max, point);
          min = Math.min(min, point);
          sum += point;
        });
      });

      this.min = min;
      this.max = max;
      this.sum = sum;
      this.avg = (max - min) / 2;
      this.nrPoints = nrPoints;
    }


    protected _initCaptions(defaults: ChartCaptions, captions: string[],
      labThis: ChartLabels, labOther: ChartLabels): _WkChartCaptions {

      const res: _WkChartCaptions = {
        fontColor: ExprOrStrToStr(labThis.fontColor || labOther.fontColor,
          defaults.fontColor, this.args),
        fontFamily: ExprOrStrToStr(labThis.fontFamily || labOther.fontFamily,
          defaults.fontFamily, this.args),
        fontSize: ExprOrNumToNum(labThis.fontSize || labOther.fontSize,
          defaults.fontSize as number, this.args),
        alignment: parseEnum(labThis.alignment, ChartCaptionAlignment, defaults.alignment),
        position: parseEnum(labThis.position, ChartCaptionPosition, defaults.position),
        orientation: parseEnum(labThis.orientation, ChartCaptionOrientation, defaults.orientation),
        marginBefore: ExprOrNumToNum(labThis.marginBefore, defaults.marginBefore as number, this.args),
        marginAfter: ExprOrNumToNum(labThis.marginAfter, defaults.marginAfter as number, this.args),
      };

      _setUpCaptionsFont(res, this.context);
      const isHorizontal = res.position === ChartCaptionPosition.top ||
        res.position === ChartCaptionPosition.bottom;

      if (isHorizontal) {
        const joinedText = captions.join(' ');
        const sz = this.context.measureText(joinedText);
        res.width = sz.width;
      } else {
        res.width = 0;
        captions.forEach(caption => {
          res.width = Math.max(res.width, this.context.measureText(caption).width);
        });
      }
      res.height = res.fontSize * 1.2;

      let d: uint;
      switch (res.position) {
        case ChartCaptionPosition.top:
          res.y = this.graphY1 + res.height + res.marginBefore;
          d = res.height + res.marginBefore + res.marginAfter;
          this.graphY1 += d;
          break;

        case ChartCaptionPosition.left:
          res.x = this.graphX0 + res.marginBefore;
          d = res.width + res.marginBefore + res.marginAfter;
          this.graphY0 = Math.min(this.graphY0, this.chartHeight - res.height / 2);
          this.graphX0 += d;
          break;

        case ChartCaptionPosition.bottom:
          res.y = this.graphY0 - res.marginAfter;
          d = res.height + res.marginBefore + res.marginAfter;
          this.graphY0 -= d;
          break;

        case ChartCaptionPosition.right:
          d = res.width + res.marginBefore + res.marginAfter;
          res.x = this.graphX1 + res.marginBefore - d;
          this.graphY0 = Math.min(this.graphY0, this.chartHeight - res.height / 2);
          this.graphX1 -= d;
          break;
      }
      return res;
    }


    protected _initTitle(params: AxisChartTaskParams): void {
      let title = params.title || {} as ChartTitle;
      if (typeof title === 'string') {
        title = {
          caption: title as string,
        };
      }

      if (title.caption) {
        this.title = this._initCaptions(_defValues.title, [title.caption], title, title);
        this.title.caption = ExprOrStrToStr(title.caption, '', this.args);
      }
    }

    protected _initLegend(params: AxisChartTaskParams): void {

      const pLegend = _ExprStrToLabels(params.legend);
      const captions: any = pLegend.captions;
      if (captions) {
        this.legend = this._initCaptions(_defValues.legend, captions, pLegend, pLegend);
        this.legend.captions = captions;
        const defMark = _defValues.legend.mark;
        const pMark = pLegend.mark || {} as ChartLegendMark;
        this.legend.mark = {
          width: ExprOrNumToNum(pMark.width, defMark.width as number, this.args),
          height: ExprOrNumToNum(pMark.height, defMark.height as number, this.args),
          spacing: ExprOrNumToNum(pMark.spacing, defMark.spacing as number, this.args),
        };
        const markWidAndSpace = this.legend.mark.width + this.legend.mark.spacing;

        switch (this.legend.position) {
          case ChartCaptionPosition.left:
            this.legend.x += markWidAndSpace;
            this.graphX0 += markWidAndSpace;
            break;

          case ChartCaptionPosition.right:
            this.graphX1 -= markWidAndSpace;
            break;
        }
      }
    }


    protected _getLegendColor(seriesI: uint, i: uint): string {
      return this.fillColors[seriesI][i];
    }


    protected _drawLegend(): void {
      const legend = this.legend;
      if (legend.captions) {
        const ctx = this.context;
        const mark = legend.mark;
        const x = legend.x;
        const y0 = legend.height;
        const h = legend.height;
        const isPointLegend = this.data.length === 1;

        legend.captions.forEach((caption, i) => {
          const y = y0 + i * h;
          _setUpCaptionsFont(legend, ctx);
          const deltaX = _alignCaptions(legend, ctx, caption, legend.width);
          ctx.fillText(caption, x + deltaX, y);
          ctx.fillStyle = isPointLegend ? this._getLegendColor(0, i) : this._getLegendColor(i, 0);
          ctx.fillRect(x + deltaX - mark.width - mark.spacing, y - (h + mark.height) / 2,
            mark.width, mark.height);
        });
      }
    }
  }

  // ------------------------------------------------------------------------
  //                               calcBestMax
  // ------------------------------------------------------------------------

  function _calcBestMax(v): number {
    const vAbs = Math.abs(v);
    const isNegative = v < 0;
    const l10v = Math.log10(vAbs);
    const l10vf = Math.floor(l10v);
    const vBase = 10 ** l10vf;
    const vSubDigits = vAbs % vBase;
    if (Math.abs(vSubDigits) > 0.00001) {
      const vLow = vAbs - vSubDigits;
      const vHigh = (isNegative ? -vLow + vBase : vLow + vBase);
      return vHigh;
      // console.log(v, l10v, l10vf, vSubDigits, vLow, vHigh);
    } else {
      return v;
      // console.log(v);
    }
  }

  // ------------------------------------------------------------------------
  //                               Axis Chart
  // ------------------------------------------------------------------------

  interface XDrawPoint {
    x: uint;
    xLabel: uint;
    xLabelWidth: uint;
    series: { x: uint, w: uint }[];
  }


  class _WkAxisChart extends _WkChart {

    /** Chart Type per series. Use only if chartType is `mixed`. */
    chartTypes: ChartTypes[];

    // axis
    xAxis: _WkChartLine;
    yAxis: _WkChartLine;
    y0Line: _WkChartLine;

    // draw points
    xDrawPoints: XDrawPoint[] = [];
    x1: uint;

    // labels X
    labelsX: _WkChartLabels;

    // labels Y
    labelsY: _WkChartLabels;

    // markers
    markers: _WkChartMarkers;
    hasMarkers: boolean;

    // points
    pointMaxHeight: uint;

    // colors
    negativeFillColors: string[][];

    // limits
    maxValue: number;
    bestMaxValue: number;
    minValue: number;
    avgValue: number;


    protected _calcCaptions(captions: string | string[],
      count: uint, min: number, max: number): string[] {
      const strCaption = captions as string;
      if (!strCaption || !Array.isArray(strCaption)) {
        const isCaptionsExpr = isExpr(strCaption as string);
        const newCaptions = [];
        const delta = (max - min) / (count - 1);
        for (let i = 0; i < count; i++) {
          const v = min + i * delta;
          if (isCaptionsExpr) {
            this.args.vars['v'] = v;
            const v1 = calcExpr(strCaption as string, this.args);
            newCaptions.push(v1.toString());
          } else {
            newCaptions.push(v.toString());
          }
        }
        captions = newCaptions;
      }
      return captions as string[];
    }


    protected _initLabels(params: AxisChartTaskParams): void {

      const labelsX: ChartLabelsX = _ExprStrToLabels(params.labelsX);
      const labelsY: ChartLabelsY = _ExprStrToLabels(params.labelsY);
      let captions;

      // labels X
      captions = labelsX.captions;
      if (captions) {
        captions = this._calcCaptions(captions, this.nrPoints, 0, this.nrPoints - 1);
        this.labelsX = this._initCaptions(_defValues.labelsX, captions, labelsX, labelsY);
        this.labelsX.captions = captions;
      }

      // labels Y
      captions = labelsY.captions;
      if (labelsY.tickCount !== 0 || captions) {
        captions = this._calcCaptions(captions,
          labelsY.tickCount || _defValues.labelsY.tickCount,
          this.minValue, this.maxValue);

        this.labelsY = this._initCaptions(_defValues.labelsY, captions, labelsY, labelsX);
        this.labelsY.captions = captions;
        // in case there is no title make sure there is enough space for the labelsY
        const heightDiv2 = this.labelsY.height / 2;
        this.graphY1 = Math.max(this.graphY1, heightDiv2);
      }
    }


    protected _getLegendColor(seriesI: uint, i: uint): string {
      return this.chartTypes[seriesI] !== ChartTypes.line
        ? this.fillColors[seriesI][i]
        : this.strokeColors[seriesI][i];
    }

    protected _initLine(line: ChartLine): _WkChartLine {

      return {
        visible: line.visible !== undefined ? line.visible : true,
        color: ExprOrStrToStr(line.color, '#7c7c7c', this.args),
        width: ExprOrNumToNum(line.width, 1, this.args),
      };
    }


    protected _initMarkers(params: AxisChartTaskParams): void {
      const markers: _WkChartMarkers = {};
      this.hasMarkers = params.markers !== undefined || this.chartTypes
        .findIndex(cType => cType === ChartTypes.marker) !== -1;

      const pMarkers = params.markers || {};

      if (this.hasMarkers) {
        markers.visible = this._fillArrayArrayParam<boolean, boolean>(
          pMarkers.visible, this.chartType === ChartTypes.marker);
        markers.shape = this._fillArrayArrayParam<ChartPointShape | string, ChartPointShape>(
          pMarkers.shape, _defValues.markers.shape as ChartPointShape, ChartPointShape);
        markers.size = this._fillArrayArrayParam<uint, uint>(
          pMarkers.size, _defValues.markers.size as uint);
        markers.color = this._fillArrayArrayParam<string, string>(
          pMarkers.color, _defValues.markers.color as string);

        this.overflow = _maxOfArrayArray(markers.size, this.overflow);
      }
      this.markers = markers;
    }


    protected _drawMarkers(dataPixels: int[][][]): void {
      const points = this.markers;
      const ctx = this.context;

      this.data.forEach((series, seriesI) => {
        for (let i = 0; i < series.length; i++) {
          if (points.visible[seriesI][i]) {
            ctx.fillStyle = points.color[seriesI][i];
            const size = points.size[seriesI][i];
            const sizeDiv2 = size / 2;
            const [x, y] = dataPixels[seriesI][i];

            switch (points.shape[seriesI][i]) {
              case ChartPointShape.circle:
                ctx.beginPath();
                ctx.arc(x, y, sizeDiv2, 0, Math.PI * 2);
                ctx.fill();
                break;

              case ChartPointShape.diamond:
                ctx.beginPath();
                ctx.moveTo(x - sizeDiv2, y);
                ctx.lineTo(x, y - sizeDiv2);
                ctx.lineTo(x + sizeDiv2, y);
                ctx.lineTo(x, y + sizeDiv2);
                ctx.fill();
                break;

              case ChartPointShape.square:
                ctx.fillRect(x - sizeDiv2, y - sizeDiv2, sizeDiv2, sizeDiv2);
                break;
            }
          }
        }
      });
    }


    protected _drawLine(line: _WkChartLine,
      x0: uint, y0: uint, x1: uint, y1: uint): void {

      const ctx = this.context;
      ctx.beginPath();
      ctx.strokeStyle = line.color;
      ctx.lineWidth = line.width;
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y1);
      ctx.stroke();
    }


    protected _computeBestValues(): void {
      this.bestMaxValue = _calcBestMax(this.max);
    }


    protected _computeDrawPoints(params: AxisChartTaskParams): void {

      this.pointMaxHeight = ExprOrNumToNum(params.pointMaxHeight, _defValues.pointMaxHeight, this.args);
      const x0 = this.graphX0 + this.overflow;
      const x1 = this.graphX1 - this.overflow;
      const xWidth = x1 - x0;
      const nrPoints = this.nrPoints;
      const pointArea = xWidth / nrPoints;
      let pointDistance = ExprOrNumToNum(params.pointDistance, _defValues.pointDistance, this.args);
      pointDistance = pointDistance || pointArea;
      let x = x0;

      const barChartCount = this.chartTypes.reduce((acc, v) =>
        acc + (v === ChartTypes.bar ? 1 : 0));

      if (barChartCount === 0) {
        for (let i = 0; i < nrPoints; i++) {
          const xMidPoint = x + pointDistance / 2;
          this.xDrawPoints.push({
            x,
            xLabel: x,
            xLabelWidth: pointDistance,
            series: this.data.map(() => {
              return { x: xMidPoint, w: pointDistance };
            }),
          });
          x += pointDistance;
        }
      } else {
        // charts with bars required a special calculation
        let barWidth = ExprOrNumToNum(params.barWidth, _defValues.barWidth, this.args);
        const seriesSpacing = ExprOrNumToNum(params.seriesSpacing, _defValues.seriesSpacing, this.args);
        if (!barWidth) {
          barWidth = (pointDistance / barChartCount) - seriesSpacing;
        }
        const usedPointWidth = barWidth * barChartCount +
          seriesSpacing * (barChartCount - 1);
        for (let i = 0; i < nrPoints; i++) {
          let xBar = x;
          const xMidPoint = x + pointDistance / 2;
          this.xDrawPoints.push({
            x,
            xLabel: x,
            xLabelWidth: usedPointWidth,
            series: this.data.map((_series, seriesI) => {
              if (this.chartTypes[seriesI] === ChartTypes.bar) {
                const xBarThis = xBar;
                xBar += barWidth + seriesSpacing;
                return { x: xBarThis, w: barWidth };
              }
              return { x: xMidPoint, w: pointDistance };
            }),
          });
          x += pointDistance;
        }
      }
      this.x1 = x;
    }


    /** Initializes all the Axis Chart parameters. */
    _initChart(params: AxisChartTaskParams): void {

      this.chartTypes = this.data.map((_series, seriesIndex) => {
        if (this.chartType !== ChartTypes.mixed) {
          return this.chartType;
        }

        if (!params.chartTypes || params.chartTypes.length <= seriesIndex) {
          return ChartTypes.bar;
        }

        return parseEnum(params.chartTypes[seriesIndex], ChartTypes, ChartTypes.bar);
      });

      // axis
      this.xAxis = this._initLine(params.xAxis || {});
      this.yAxis = this._initLine(params.yAxis || {});
      this.y0Line = this._initLine(params.y0Line || {});


      // limits
      this._computeBestValues();
      this.maxValue = ExprOrNumToNum(params.maxValue, this.bestMaxValue, this.args);
      this.minValue = ExprOrNumToNum(params.minValue, Math.min(this.min, 0), this.args);
      this.avgValue = this.avg;

      super._initChart(params);

      // colors
      this.negativeFillColors = !params.negativeFillColors ? this.fillColors :
        this._fillArrayArrayParam<string, string>(params.negativeFillColors, 'white');

      this._initMarkers(params);
      this._initLabels(params);
      this._computeDrawPoints(params);

      // animation
      this.props['point-height'] = ExprOrNumToNum(params.pointHeightStart, 1, this.args);
      this.props['deviation'] = ExprOrNumToNum(params.deviationStart, 1, this.args);
      this.props['sweep'] = ExprOrNumToNum(params.sweepStart, 1, this.args);
    }


    /** Implements Axis Chart animation. */
    _drawChart(params: AxisChartTaskParams): void {

      const pointHeight = this.props['point-height'];
      const deviationV = this.props['deviation'];
      const sweepV = this.props['sweep'];

      const chartWidth = this.chartWidth;
      const chartHeight = this.chartHeight;
      const ctx = this.context;
      const x0 = this.graphX0;
      const y0 = this.graphY0;
      const y1 = this.graphY1;
      const topMargin = 1;
      const yLength = y0 - y1 - topMargin;

      // values
      const maxValue = this.maxValue;
      const minValue = this.minValue;
      const valueRange = maxValue - minValue;

      // y0 line
      const hasY0Line = maxValue * minValue < 0;
      const vy0Line = hasY0Line ? 0 : minValue >= 0 ? minValue : maxValue;
      const vy0LineClip = (vy0Line - minValue) / valueRange;
      const axis0Y = y0 - yLength * vy0LineClip;

      // data
      const data = this.data;
      const nrPoints = this.nrPoints;

      const drawNrPoints = sweepV >= 1 ? nrPoints :
        Math.max(Math.min(Math.floor(nrPoints * sweepV) + 1, nrPoints), 0);

      ctx.clearRect(0, 0, chartWidth, chartHeight);
      super._drawChart(params);

      const y = axis0Y;
      const dataMidPixels: int[][][] = [];
      // data points
      data.forEach((series, seriesI) => {

        let xPrev: int;
        let yPrev: int;
        const seriesPixels: int[][] = [];
        const seriesMidPixels: int[][] = [];

        const chartType = this.chartTypes[seriesI];

        for (let i = 0; i < drawNrPoints; i++) {

          ctx.lineWidth = this.strokeWidth[seriesI][i];
          ctx.strokeStyle = this.strokeColors[seriesI][i];

          let v = series[i];
          if (Math.abs(deviationV - 1) > 1e-6) {
            v = this.avgValue - ((this.avgValue - v) * deviationV);
          }

          ctx.fillStyle = v >= 0 ? this.fillColors[seriesI][i] :
            this.negativeFillColors[seriesI][i];

          const xDrawPoint = this.xDrawPoints[i].series[seriesI];

          // values
          const vClip = (v - vy0Line) / valueRange;
          const vT = vClip * pointHeight;
          // y
          const yLen = -yLength * vT;
          let yNew = yLen + y;
          // x
          const x = xDrawPoint.x;
          let xNew = x;

          const isSweeping = (i === drawNrPoints - 1) && (sweepV < 1);
          if (isSweeping) {
            const leftSweep = (sweepV - i / nrPoints);
            const reSweep = leftSweep / (1 / nrPoints);
            xNew = ((xNew - xPrev) * reSweep) + xPrev;
            yNew = ((yNew - yPrev) * reSweep) + yPrev;
          }

          let xMidNew = xNew;
          const yMidNew = yNew;

          switch (chartType) {
            case ChartTypes.bar:
              let barWidth = xDrawPoint.w;
              if (isSweeping) {
                const xSeriesDrawPt = this.xDrawPoints[i];
                const xMaxSweepPos = xSeriesDrawPt.xLabel + xSeriesDrawPt.xLabelWidth * sweepV;
                if (xMaxSweepPos < x) {
                  barWidth = 0;
                } else {
                  barWidth = Math.min(x + barWidth, xMaxSweepPos) - x;
                }
              }
              if (barWidth > 0) {
                ctx.fillRect(x, y, barWidth, yLen);
                ctx.strokeRect(x, y, barWidth, yLen);
              }
              xMidNew = x + barWidth / 2;
              break;

            case ChartTypes.line:
              if (i) {
                ctx.beginPath();
                ctx.moveTo(xPrev, yPrev);
                ctx.lineTo(xNew, yNew);
                ctx.stroke();
              }
              break;
          }

          xPrev = xNew;
          yPrev = yNew;
          seriesPixels.push([xNew, yNew]);
          seriesMidPixels.push([xMidNew, yMidNew]);
        }

        if (chartType === ChartTypes.area) {
          ctx.beginPath();
          ctx.moveTo(seriesPixels[0][0], y);
          seriesPixels.forEach(point => {
            ctx.lineTo(point[0], point[1]);
          });
          ctx.lineTo(seriesPixels[seriesPixels.length - 1][0], y);
          ctx.lineTo(seriesPixels[0][0], y);
          ctx.fill();
          ctx.stroke();
        }

        dataMidPixels.push(seriesMidPixels);
      });

      ctx.lineWidth = 1;

      // markers
      if (this.hasMarkers) {
        this._drawMarkers(dataMidPixels);
      }

      // titles
      const titleCaption = this.title.caption;
      if (this.title.caption) {
        _setUpCaptionsFont(this.title, ctx);
        const titleXPos = _alignCaptions(this.title, ctx,
          titleCaption, this.x1 - this.graphX0);
        ctx.fillText(titleCaption, this.graphX0 + titleXPos, this.title.y);
      }

      let captions: string[];
      // labelsX
      if (this.labelsX) {
        _setUpCaptionsFont(this.labelsX, ctx);
        captions = this.labelsX.captions;
        for (let i = 0; i < captions.length; i++) {
          const x = this.xDrawPoints[i].xLabel;
          const text = captions[i];
          const deltaX = _alignCaptions(this.labelsX, ctx, text, this.xDrawPoints[i].xLabelWidth);
          ctx.fillText(text, x + deltaX, this.labelsX.y);
        }
      }

      // labelsY
      if (this.labelsY) {
        _setUpCaptionsFont(this.labelsY, ctx);
        captions = this.labelsY.captions;
        const fs2 = this.labelsY.height / 2;
        const scale = yLength / (captions.length - 1);
        for (let i = 0; i < captions.length; i++) {
          const yi = y0 - scale * i;
          const text = this.labelsY.captions[i];
          const deltaX = _alignCaptions(this.labelsY, ctx, text, this.labelsY.width);
          ctx.fillText(text, this.labelsY.x + deltaX, yi + fs2);
        }
      }

      // y0Line
      if (hasY0Line && this.y0Line.visible) {
        this._drawLine(this.y0Line, x0, axis0Y, this.x1, axis0Y);
      }

      // x-axis
      if (this.xAxis.visible) {
        this._drawLine(this.xAxis, x0, y0, this.x1, y0);
      }

      // y-axis
      if (this.yAxis.visible) {
        this._drawLine(this.yAxis, x0, y0, x0, y0 - yLength);
      }
    }
  }

  // ------------------------------------------------------------------------
  //                               Pie Chart
  // ------------------------------------------------------------------------

  class _WkPieChart extends _WkChart {

    _initChart(params: PieChartTaskParams): void {
      super._initChart(params);
      // animation
      this.props['angle'] = ExprOrNumToNum(params.angleStart, 0, this.args);
      this.props['dispersion'] = ExprOrNumToNum(params.dispersionStart, 1, this.args);
    }


    _drawChart(params: PieChartTaskParams): void {

      const angle = this.props['angle'];
      const dispersion = this.props['dispersion'];
      const isClockwise = params.isClockwise !== false;
      const overflow = this.overflow;
      const x0 = this.graphX0 + overflow;
      const y1 = this.graphY1 + overflow;
      const diameter = Math.min(this.graphX1 - x0 - overflow, this.graphY0 - y1 - overflow);
      const radius = diameter / 2;
      const ctx = this.context;

      ctx.clearRect(0, 0, this.chartWidth, this.chartHeight);
      super._drawChart(params);

      this.data.forEach((series, seriesI) => {

        for (let stage = 0; stage < 2; stage++) {
          let startAngle = angle;
          for (let i = 0; i < series.length; i++) {
            ctx.lineWidth = this.strokeWidth[seriesI][i];
            ctx.strokeStyle = this.strokeColors[seriesI][i];
            ctx.fillStyle = this.fillColors[seriesI][i];

            const point = series[i];
            const percentage = point / this.sum;
            let endAngle = (percentage * Math.PI * 2 * dispersion);
            if (!isClockwise) { endAngle = -endAngle; }
            endAngle += startAngle;

            ctx.beginPath();
            ctx.moveTo(x0 + radius, y1 + radius);
            ctx.arc(x0 + radius, y1 + radius, radius, startAngle, endAngle);
            ctx.closePath();
            if (stage === 0) {
              ctx.fill();
            } else {
              ctx.stroke();
            }
            startAngle = endAngle;
          }
        }
      });
    }
  }

  // ------------------------------------------------------------------------
  //                               Chart Task
  // ------------------------------------------------------------------------

  pluginManager.addTasks([['chart', _chartTask]]);


  /** Implements the Chart Task */
  function _chartTask(anime: Animation, _wkTask: WorkTask,
    params: BaseChartTaskParams, stage: uint, args: ABeamerArgs): TaskResult {

    switch (stage) {
      case TS_INIT:
        let cType = params.chartType;
        if (typeof cType === 'string') {
          cType = ChartTypes[cType] as ChartTypes;
        }

        const data = params.data;
        if (!data.length) {
          throwErr(`Series have empty data`);
        }

        let animator: _ChartVirtualAnimator;

        if (params.animeSelector) {
          animator = new _ChartVirtualAnimator();
          animator.selector = params.animeSelector;
          animator.params = params;
          args.story.addVirtualAnimator(animator);
        }

        const elAdapters = args.scene.getElementAdapters(anime.selector);
        args.vars.elCount = elAdapters.length;
        elAdapters.forEach((elAdapter, elIndex) => {

          args.vars.elIndex = elIndex;

          let chart: _WkChart;

          switch (cType) {
            case ChartTypes.pie:
              chart = new _WkPieChart(args);
              break;

            case ChartTypes.marker:
            case ChartTypes.bar:
            case ChartTypes.line:
            case ChartTypes.area:
            case ChartTypes.mixed:
              chart = new _WkAxisChart(args);
              break;
            default:
              throwI8n(Msgs.UnknownType, { p: params.chartType });
          }

          chart._init(elAdapter, cType as ChartTypes, animator);
          chart._initData(data);
          chart._initChart(params);
          chart._drawChart(params);

          if (animator) { animator.charts.push(chart); }
        });
        break;
    }
    return TR_EXIT;
  }

  // ------------------------------------------------------------------------
  //                               Testing
  // ------------------------------------------------------------------------

  /* const
    testValues = [3.33, 8.4, 10, 12, 45, 0.12, 100, 1000, 12400, 95000,
      -10, -12, -89.3, -3.4, -400];

  testValues.forEach(v => {
    _calcBestMax(v);
  }); */
}
