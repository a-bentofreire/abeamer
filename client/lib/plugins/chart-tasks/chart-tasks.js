"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// ------------------------------------------------------------------------
// Copyright (c) 2018-2024 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License.
// ------------------------------------------------------------------------
// Implements a list of built-in chart Tasks
/** @module end-user | The lines bellow convey information for the end-user */
/**
 * ## Description
 *
 * A **chart** task creates an animated chart.
 *
 * **WARN** This plugin is still in development stage, parts of API can change in the future.
 * However is already in a stage that can be used.
 *
 * This plugin has the following built-in charts:
 *
 * - [pie](#PieChartTaskParams)
 * - [bar](#AxisChartTaskParams)
 * - [area](#AxisChartTaskParams)
 * - [line](#AxisChartTaskParams)
 * - [marker](#AxisChartTaskParams)
 * - [mixed](#AxisChartTaskParams) Draws different types of chars in the same chart, uses
 *   [](#chartTypes) parameter to determine the type of each chart per series.
 *
 * read the details on [](#AxisChartTaskParams).
 *
 * ## Get started
 * How to create a simple bar chart:
 *
 * The bare-bones of a `abeamer.ini` file:
 * ```scss
 * $abeamer-width: 300;
 * $abeamer-height: 150;
 * ```
 *
 *  The bare-bones of a `html` file:
 * ```html
 * <div class="abeamer-story" id=story>
 *     <div class=abeamer-scene id=scene1>
 *       <canvas id=chart width=300 height=150></canvas>
 *     </div>
 * </div>
 * ```
 *
 * On the `hello-world` example, replace the `scene.addAnimations` with:
 * ```typescript
 * scene.addAnimations([{
 *    selector: '#chart', // JQuery selector pointing to the HtmlElement
 *    tasks: [{
 *      handler: 'chart', // is always 'chart' for charts.
 *      params: {
 *        chartType: ABeamer.ChartTypes.bar, // or 'bar' if you are using javascript
 *        labelsX: { captions: ['A', 'B', 'C', 'D', 'E'] },
 *        title: 'My first Chart',
 *        data: [[100, 200, 50, 140, 300]],
 *      } as ABeamer.AxisChartTaskParams, // comment as ... if you are using javascript
 *    }],
 *  }]);
 * ```
 * The previous example, will create a static chart.
 * To animate it, change it the to following:
 * ```typescript
 *  scene.addAnimations([{
 *   selector: 'canvas',
 *   tasks: [{
 *     handler: 'chart',
 *     params: {
 *       chartType: ABeamer.ChartTypes.bar,
 *       labelsX: { captions: ['A', 'B', 'C', 'D', 'E'] },
 *       title: 'My first Chart',
 *       data: [[100, 200, 50, 140, 300]],
 *       // animation parameters
 *       pointHeightStart: 0.1,    // defined the initial value for the animation point-height property
 *       animeSelector: 'chart-anime-01', // unique animation selector to be used by the animator
 *     } as ABeamer.AxisChartTaskParams,
 *   }],
 * }])
 *   .addAnimations([{
 *     selector: `%chart-anime-01`, // animation selector defined previously, prefixed with '%'
 *     duration: `1s`,
 *     props: [{
 *       prop: 'point-height', // property which initial value is 0.1
 *       value: 1,             // value at the end of animation
 *     }],
 *   }]);
 * ```
 */
var ABeamer;
(function (ABeamer) {
    // #generate-group-section
    // ------------------------------------------------------------------------
    //                               Chart Tasks
    // ------------------------------------------------------------------------
    // The following section contains data for the end-user
    // generated by `gulp build-definition-files`
    // -------------------------------
    // #export-section-start: release
    var ChartTypes;
    (function (ChartTypes) {
        ChartTypes[ChartTypes["pie"] = 0] = "pie";
        ChartTypes[ChartTypes["bar"] = 1] = "bar";
        ChartTypes[ChartTypes["area"] = 2] = "area";
        ChartTypes[ChartTypes["line"] = 3] = "line";
        ChartTypes[ChartTypes["marker"] = 4] = "marker";
        ChartTypes[ChartTypes["mixed"] = 5] = "mixed";
    })(ChartTypes = ABeamer.ChartTypes || (ABeamer.ChartTypes = {}));
    var ChartCaptionOrientation;
    (function (ChartCaptionOrientation) {
        ChartCaptionOrientation[ChartCaptionOrientation["horizontal"] = 0] = "horizontal";
        ChartCaptionOrientation[ChartCaptionOrientation["vertical"] = 1] = "vertical";
    })(ChartCaptionOrientation = ABeamer.ChartCaptionOrientation || (ABeamer.ChartCaptionOrientation = {}));
    var ChartCaptionPosition;
    (function (ChartCaptionPosition) {
        ChartCaptionPosition[ChartCaptionPosition["top"] = 0] = "top";
        ChartCaptionPosition[ChartCaptionPosition["bottom"] = 1] = "bottom";
        ChartCaptionPosition[ChartCaptionPosition["left"] = 2] = "left";
        ChartCaptionPosition[ChartCaptionPosition["right"] = 3] = "right";
    })(ChartCaptionPosition = ABeamer.ChartCaptionPosition || (ABeamer.ChartCaptionPosition = {}));
    var ChartCaptionAlignment;
    (function (ChartCaptionAlignment) {
        ChartCaptionAlignment[ChartCaptionAlignment["left"] = 0] = "left";
        ChartCaptionAlignment[ChartCaptionAlignment["center"] = 1] = "center";
        ChartCaptionAlignment[ChartCaptionAlignment["right"] = 2] = "right";
    })(ChartCaptionAlignment = ABeamer.ChartCaptionAlignment || (ABeamer.ChartCaptionAlignment = {}));
    var ChartPointShape;
    (function (ChartPointShape) {
        ChartPointShape[ChartPointShape["circle"] = 0] = "circle";
        ChartPointShape[ChartPointShape["square"] = 1] = "square";
        ChartPointShape[ChartPointShape["diamond"] = 2] = "diamond";
    })(ChartPointShape = ABeamer.ChartPointShape || (ABeamer.ChartPointShape = {}));
    // #export-section-end: release
    // -------------------------------
    // ------------------------------------------------------------------------
    //                               Implementation
    // ------------------------------------------------------------------------
    ABeamer.pluginManager.addPlugin({
        id: 'abeamer.chart-tasks',
        uuid: '73631f28-df71-4b4d-88e1-c99a858e0fd3',
        author: 'Alexandre Bento Freire',
        email: 'abeamer@a-bentofreire.com',
        jsUrls: ['plugins/chart-tasks/chart-tasks.js'],
        teleportable: true,
    });
    var _defValues = ABeamer.getVars()['chart'] = {
        labelsX: {
            fontFamily: 'sans-serif',
            fontColor: 'black',
            fontSize: 12,
            alignment: ChartCaptionAlignment.center,
            position: ChartCaptionPosition.bottom,
            orientation: ChartCaptionOrientation.horizontal,
            marginBefore: 0,
            marginAfter: 0,
        },
        labelsY: {
            fontFamily: 'sans-serif',
            fontColor: 'black',
            fontSize: 12,
            alignment: ChartCaptionAlignment.right,
            position: ChartCaptionPosition.left,
            orientation: ChartCaptionOrientation.horizontal,
            marginBefore: 0,
            marginAfter: 5,
            tickCount: 6,
        },
        legend: {
            fontFamily: 'sans-serif',
            fontColor: 'black',
            fontSize: 12,
            alignment: ChartCaptionAlignment.left,
            position: ChartCaptionPosition.right,
            orientation: ChartCaptionOrientation.horizontal,
            marginBefore: 0,
            marginAfter: 5,
            mark: {
                width: 10,
                height: 3,
                spacing: 4,
            },
        },
        title: {
            fontFamily: 'sans-serif',
            fontColor: 'black',
            fontSize: 14,
            alignment: ChartCaptionAlignment.center,
            position: ChartCaptionPosition.top,
            orientation: ChartCaptionOrientation.horizontal,
            marginBefore: 0,
            marginAfter: 0,
        },
        fillColors: '#ffecad',
        strokeColors: '#101010',
        strokeWidth: 1,
        markers: {
            shape: ChartPointShape.square,
            size: 5,
            color: 'black',
        },
        barWidth: 0,
        pointMaxHeight: 100,
        pointDistance: 0,
        seriesSpacing: 3,
        nrPoints: 10,
    };
    /**
     * Returns the maximum value of array of array of numbers.
     */
    function _maxOfArrayArray(data, startValue) {
        data.forEach(function (series) {
            series.forEach(function (point) {
                startValue = Math.max(startValue, point);
            });
        });
        return startValue;
    }
    // ------------------------------------------------------------------------
    //                               _ChartVirtualAnimator
    // ------------------------------------------------------------------------
    var _ChartVirtualAnimator = /** @class */ (function (_super) {
        __extends(_ChartVirtualAnimator, _super);
        function _ChartVirtualAnimator() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.charts = [];
            return _this;
        }
        _ChartVirtualAnimator.prototype.animateProps = function () {
            var _this = this;
            this.charts.forEach(function (chart) {
                chart._drawChart(_this.params);
            });
        };
        return _ChartVirtualAnimator;
    }(ABeamer.SimpleVirtualAnimator));
    function _setUpCaptionsFont(l, ctx) {
        ctx.font = l.fontSize + "px " + l.fontFamily;
        ctx.fillStyle = l.fontColor;
        ctx.textBaseline = 'bottom';
    }
    function _ExprStrToLabels(l) {
        switch (typeof l) {
            case 'undefined': return {};
            case 'string': return { captions: l };
            default:
                return l;
        }
    }
    function _alignCaptions(l, ctx, text, width) {
        if (l.alignment === ChartCaptionAlignment.left) {
            return 0;
        }
        // let style: CSSStyleDeclaration;
        // if (!testDiv) {
        //   testDiv = document.createElement('div');
        //   style = testDiv.style;
        //   style.position = 'absolute';
        //   style.top = '0px';
        //   style.left = '0px';
        //   style.width = '1px';
        //   style.height = '0px';
        //   document.body.appendChild(testDiv);
        // }
        // style = testDiv.style;
        // style.display = 'inline-block';
        // style.fontFamily = l.fontFamily;
        // style.fontSize = l.fontSize + 'px';
        // testDiv.textContent = text;
        // style.display = 'none';
        // @TODO: Implement a better way to compute the text height
        var sz = ctx.measureText(text);
        switch (l.alignment) {
            case ChartCaptionAlignment.center:
                return (width - sz.width) / 2;
            case ChartCaptionAlignment.right:
                return (width - sz.width);
        }
        return 0;
    }
    var _WkChart = /** @class */ (function () {
        function _WkChart(args) {
            this.args = args;
            // title
            this.title = {};
            // legends
            this.legend = {};
            // overflow
            this.overflow = 0;
            // graph  (x0, y0) = (left, bottom)
            this.graphX0 = 0;
            this.graphY1 = 0;
        }
        _WkChart.prototype._drawChart = function (_params) {
            this._drawLegend();
        };
        _WkChart.prototype._fillArrayArrayParam = function (param, defValue, strMapper) {
            var res = [];
            if (param === undefined) {
                param = defValue;
            }
            var isParamArray = Array.isArray(param);
            if (!isParamArray && strMapper && typeof param === 'string') {
                param = strMapper[param];
            }
            this.data.forEach(function (series, seriesI) {
                var resItem = [];
                if (!isParamArray) {
                    resItem = series.map(function (_v) { return param; });
                }
                else {
                    var subParam_1 = param[seriesI];
                    var isSubParamArray = Array.isArray(subParam_1);
                    if (!isSubParamArray && strMapper && typeof subParam_1 === 'string') {
                        subParam_1 = strMapper[subParam_1];
                    }
                    if (!isSubParamArray) {
                        resItem = series.map(function (_v) { return subParam_1; });
                    }
                    else {
                        resItem = series.map(function (_v, i) {
                            var itemParam = subParam_1[i];
                            if (strMapper && typeof itemParam === 'string') {
                                itemParam = strMapper[itemParam];
                            }
                            return itemParam;
                        });
                    }
                }
                res.push(resItem);
            });
            return res;
        };
        _WkChart.prototype._initChart = function (params) {
            // colors
            this.fillColors = this._fillArrayArrayParam(params.fillColors, _defValues.fillColors);
            this.strokeColors = this._fillArrayArrayParam(params.strokeColors, _defValues.strokeColors);
            this.strokeWidth = this._fillArrayArrayParam(params.strokeWidth, _defValues.strokeWidth);
            this.overflow = _maxOfArrayArray(this.strokeWidth, this.overflow);
            this.graphX1 = this.chartWidth;
            this.graphY0 = this.chartHeight;
            this._initTitle(params);
            this._initLegend(params);
        };
        _WkChart.prototype._init = function (elAdapter, chartType, animator) {
            this.canvas = elAdapter.getProp('element', this.args);
            if (!this.canvas) {
                ABeamer.throwErr("Didn't find the " + elAdapter.getId());
            }
            this.context = this.canvas.getContext('2d');
            this.chartWidth = this.canvas.width;
            this.chartHeight = this.canvas.height;
            this.chartType = chartType;
            this.animator = animator;
            this.props = animator ? animator.props : {};
        };
        _WkChart.prototype._initData = function (data) {
            var _this = this;
            var max = -Number.MIN_VALUE;
            var min = Number.MAX_VALUE;
            var sum = 0;
            var nrPoints;
            this.data = data.map(function (series, seriesI) {
                var res;
                if (Array.isArray(series)) {
                    res = series;
                }
                else {
                    res = [];
                    var exprSeries = series;
                    var v0 = exprSeries.startValue || 0;
                    var step = exprSeries.step || 1;
                    var nrPts = exprSeries.nrPoints || nrPoints || _defValues.nrPoints;
                    _this.args.vars.n = nrPts;
                    for (var i = 0; i < nrPts; i++) {
                        _this.args.vars.v = i * step + v0;
                        var v1 = ABeamer.calcExpr(exprSeries.expr, _this.args);
                        res.push(typeof v1 === 'number' ? v1 : parseFloat(v1));
                    }
                }
                if (!seriesI) {
                    nrPoints = res.length;
                }
                else {
                    if (res.length !== nrPoints) {
                        ABeamer.throwErr("Every Series must have the same number of points");
                    }
                }
                return res;
            });
            this.data.forEach(function (series) {
                series.forEach(function (point) {
                    max = Math.max(max, point);
                    min = Math.min(min, point);
                    sum += point;
                });
            });
            this.min = min;
            this.max = max;
            this.sum = sum;
            this.avg = (max - min) / 2;
            this.nrPoints = nrPoints;
        };
        _WkChart.prototype._initCaptions = function (defaults, captions, labThis, labOther) {
            var _this = this;
            var res = {
                fontColor: ABeamer.ExprOrStrToStr(labThis.fontColor || labOther.fontColor, defaults.fontColor, this.args),
                fontFamily: ABeamer.ExprOrStrToStr(labThis.fontFamily || labOther.fontFamily, defaults.fontFamily, this.args),
                fontSize: ABeamer.ExprOrNumToNum(labThis.fontSize || labOther.fontSize, defaults.fontSize, this.args),
                alignment: ABeamer.parseEnum(labThis.alignment, ChartCaptionAlignment, defaults.alignment),
                position: ABeamer.parseEnum(labThis.position, ChartCaptionPosition, defaults.position),
                orientation: ABeamer.parseEnum(labThis.orientation, ChartCaptionOrientation, defaults.orientation),
                marginBefore: ABeamer.ExprOrNumToNum(labThis.marginBefore, defaults.marginBefore, this.args),
                marginAfter: ABeamer.ExprOrNumToNum(labThis.marginAfter, defaults.marginAfter, this.args),
            };
            _setUpCaptionsFont(res, this.context);
            var isHorizontal = res.position === ChartCaptionPosition.top ||
                res.position === ChartCaptionPosition.bottom;
            if (isHorizontal) {
                var joinedText = captions.join(' ');
                var sz = this.context.measureText(joinedText);
                res.width = sz.width;
            }
            else {
                res.width = 0;
                captions.forEach(function (caption) {
                    res.width = Math.max(res.width, _this.context.measureText(caption).width);
                });
            }
            res.height = res.fontSize * 1.2;
            var d;
            switch (res.position) {
                case ChartCaptionPosition.top:
                    res.y = this.graphY1 + res.height + res.marginBefore;
                    d = res.height + res.marginBefore + res.marginAfter;
                    this.graphY1 += d;
                    break;
                case ChartCaptionPosition.left:
                    res.x = this.graphX0 + res.marginBefore;
                    d = res.width + res.marginBefore + res.marginAfter;
                    this.graphY0 = Math.min(this.graphY0, this.chartHeight - res.height / 2);
                    this.graphX0 += d;
                    break;
                case ChartCaptionPosition.bottom:
                    res.y = this.graphY0 - res.marginAfter;
                    d = res.height + res.marginBefore + res.marginAfter;
                    this.graphY0 -= d;
                    break;
                case ChartCaptionPosition.right:
                    d = res.width + res.marginBefore + res.marginAfter;
                    res.x = this.graphX1 + res.marginBefore - d;
                    this.graphY0 = Math.min(this.graphY0, this.chartHeight - res.height / 2);
                    this.graphX1 -= d;
                    break;
            }
            return res;
        };
        _WkChart.prototype._initTitle = function (params) {
            var title = params.title || {};
            if (typeof title === 'string') {
                title = {
                    caption: title,
                };
            }
            if (title.caption) {
                this.title = this._initCaptions(_defValues.title, [title.caption], title, title);
                this.title.caption = ABeamer.ExprOrStrToStr(title.caption, '', this.args);
            }
        };
        _WkChart.prototype._initLegend = function (params) {
            var pLegend = _ExprStrToLabels(params.legend);
            var captions = pLegend.captions;
            if (captions) {
                this.legend = this._initCaptions(_defValues.legend, captions, pLegend, pLegend);
                this.legend.captions = captions;
                var defMark = _defValues.legend.mark;
                var pMark = pLegend.mark || {};
                this.legend.mark = {
                    width: ABeamer.ExprOrNumToNum(pMark.width, defMark.width, this.args),
                    height: ABeamer.ExprOrNumToNum(pMark.height, defMark.height, this.args),
                    spacing: ABeamer.ExprOrNumToNum(pMark.spacing, defMark.spacing, this.args),
                };
                var markWidAndSpace = this.legend.mark.width + this.legend.mark.spacing;
                switch (this.legend.position) {
                    case ChartCaptionPosition.left:
                        this.legend.x += markWidAndSpace;
                        this.graphX0 += markWidAndSpace;
                        break;
                    case ChartCaptionPosition.right:
                        this.graphX1 -= markWidAndSpace;
                        break;
                }
            }
        };
        _WkChart.prototype._getLegendColor = function (seriesI, i) {
            return this.fillColors[seriesI][i];
        };
        _WkChart.prototype._drawLegend = function () {
            var _this = this;
            var legend = this.legend;
            if (legend.captions) {
                var ctx_1 = this.context;
                var mark_1 = legend.mark;
                var x_1 = legend.x;
                var y0_1 = legend.height;
                var h_1 = legend.height;
                var isPointLegend_1 = this.data.length === 1;
                legend.captions.forEach(function (caption, i) {
                    var y = y0_1 + i * h_1;
                    _setUpCaptionsFont(legend, ctx_1);
                    var deltaX = _alignCaptions(legend, ctx_1, caption, legend.width);
                    ctx_1.fillText(caption, x_1 + deltaX, y);
                    ctx_1.fillStyle = isPointLegend_1 ? _this._getLegendColor(0, i) : _this._getLegendColor(i, 0);
                    ctx_1.fillRect(x_1 + deltaX - mark_1.width - mark_1.spacing, y - (h_1 + mark_1.height) / 2, mark_1.width, mark_1.height);
                });
            }
        };
        return _WkChart;
    }());
    // ------------------------------------------------------------------------
    //                               calcBestMax
    // ------------------------------------------------------------------------
    function _calcBestMax(v) {
        var vAbs = Math.abs(v);
        var isNegative = v < 0;
        var l10v = Math.log10(vAbs);
        var l10vf = Math.floor(l10v);
        var vBase = Math.pow(10, l10vf);
        var vSubDigits = vAbs % vBase;
        if (Math.abs(vSubDigits) > 0.00001) {
            var vLow = vAbs - vSubDigits;
            var vHigh = (isNegative ? -vLow + vBase : vLow + vBase);
            return vHigh;
            // console.log(v, l10v, l10vf, vSubDigits, vLow, vHigh);
        }
        else {
            return v;
            // console.log(v);
        }
    }
    var _WkAxisChart = /** @class */ (function (_super) {
        __extends(_WkAxisChart, _super);
        function _WkAxisChart() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            // draw points
            _this.xDrawPoints = [];
            return _this;
        }
        _WkAxisChart.prototype._calcCaptions = function (captions, count, min, max) {
            var strCaption = captions;
            if (!strCaption || !Array.isArray(strCaption)) {
                var isCaptionsExpr = ABeamer.isExpr(strCaption);
                var newCaptions = [];
                var delta = (max - min) / (count - 1);
                for (var i = 0; i < count; i++) {
                    var v = min + i * delta;
                    if (isCaptionsExpr) {
                        this.args.vars['v'] = v;
                        var v1 = ABeamer.calcExpr(strCaption, this.args);
                        newCaptions.push(v1.toString());
                    }
                    else {
                        newCaptions.push(v.toString());
                    }
                }
                captions = newCaptions;
            }
            return captions;
        };
        _WkAxisChart.prototype._initLabels = function (params) {
            var labelsX = _ExprStrToLabels(params.labelsX);
            var labelsY = _ExprStrToLabels(params.labelsY);
            var captions;
            // labels X
            captions = labelsX.captions;
            if (captions) {
                captions = this._calcCaptions(captions, this.nrPoints, 0, this.nrPoints - 1);
                this.labelsX = this._initCaptions(_defValues.labelsX, captions, labelsX, labelsY);
                this.labelsX.captions = captions;
            }
            // labels Y
            captions = labelsY.captions;
            if (labelsY.tickCount !== 0 || captions) {
                captions = this._calcCaptions(captions, labelsY.tickCount || _defValues.labelsY.tickCount, this.minValue, this.maxValue);
                this.labelsY = this._initCaptions(_defValues.labelsY, captions, labelsY, labelsX);
                this.labelsY.captions = captions;
                // in case there is no title make sure there is enough space for the labelsY
                var heightDiv2 = this.labelsY.height / 2;
                this.graphY1 = Math.max(this.graphY1, heightDiv2);
            }
        };
        _WkAxisChart.prototype._getLegendColor = function (seriesI, i) {
            return this.chartTypes[seriesI] !== ChartTypes.line
                ? this.fillColors[seriesI][i]
                : this.strokeColors[seriesI][i];
        };
        _WkAxisChart.prototype._initLine = function (line) {
            return {
                visible: line.visible !== undefined ? line.visible : true,
                color: ABeamer.ExprOrStrToStr(line.color, '#7c7c7c', this.args),
                width: ABeamer.ExprOrNumToNum(line.width, 1, this.args),
            };
        };
        _WkAxisChart.prototype._initMarkers = function (params) {
            var markers = {};
            this.hasMarkers = params.markers !== undefined || this.chartTypes
                .findIndex(function (cType) { return cType === ChartTypes.marker; }) !== -1;
            var pMarkers = params.markers || {};
            if (this.hasMarkers) {
                markers.visible = this._fillArrayArrayParam(pMarkers.visible, this.chartType === ChartTypes.marker);
                markers.shape = this._fillArrayArrayParam(pMarkers.shape, _defValues.markers.shape, ChartPointShape);
                markers.size = this._fillArrayArrayParam(pMarkers.size, _defValues.markers.size);
                markers.color = this._fillArrayArrayParam(pMarkers.color, _defValues.markers.color);
                this.overflow = _maxOfArrayArray(markers.size, this.overflow);
            }
            this.markers = markers;
        };
        _WkAxisChart.prototype._drawMarkers = function (dataPixels) {
            var points = this.markers;
            var ctx = this.context;
            this.data.forEach(function (series, seriesI) {
                for (var i = 0; i < series.length; i++) {
                    if (points.visible[seriesI][i]) {
                        ctx.fillStyle = points.color[seriesI][i];
                        var size = points.size[seriesI][i];
                        var sizeDiv2 = size / 2;
                        var _a = dataPixels[seriesI][i], x = _a[0], y = _a[1];
                        switch (points.shape[seriesI][i]) {
                            case ChartPointShape.circle:
                                ctx.beginPath();
                                ctx.arc(x, y, sizeDiv2, 0, Math.PI * 2);
                                ctx.fill();
                                break;
                            case ChartPointShape.diamond:
                                ctx.beginPath();
                                ctx.moveTo(x - sizeDiv2, y);
                                ctx.lineTo(x, y - sizeDiv2);
                                ctx.lineTo(x + sizeDiv2, y);
                                ctx.lineTo(x, y + sizeDiv2);
                                ctx.fill();
                                break;
                            case ChartPointShape.square:
                                ctx.fillRect(x - sizeDiv2, y - sizeDiv2, sizeDiv2, sizeDiv2);
                                break;
                        }
                    }
                }
            });
        };
        _WkAxisChart.prototype._drawLine = function (line, x0, y0, x1, y1) {
            var ctx = this.context;
            ctx.beginPath();
            ctx.strokeStyle = line.color;
            ctx.lineWidth = line.width;
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
        };
        _WkAxisChart.prototype._computeBestValues = function () {
            this.bestMaxValue = _calcBestMax(this.max);
        };
        _WkAxisChart.prototype._computeDrawPoints = function (params) {
            var _this = this;
            this.pointMaxHeight = ABeamer.ExprOrNumToNum(params.pointMaxHeight, _defValues.pointMaxHeight, this.args);
            var x0 = this.graphX0 + this.overflow;
            var x1 = this.graphX1 - this.overflow;
            var xWidth = x1 - x0;
            var nrPoints = this.nrPoints;
            var pointArea = xWidth / nrPoints;
            var pointDistance = ABeamer.ExprOrNumToNum(params.pointDistance, _defValues.pointDistance, this.args);
            pointDistance = pointDistance || pointArea;
            var x = x0;
            var barChartCount = this.chartTypes.reduce(function (acc, v) {
                return acc + (v === ChartTypes.bar ? 1 : 0);
            });
            if (barChartCount === 0) {
                var _loop_1 = function (i) {
                    var xMidPoint = x + pointDistance / 2;
                    this_1.xDrawPoints.push({
                        x: x,
                        xLabel: x,
                        xLabelWidth: pointDistance,
                        series: this_1.data.map(function () {
                            return { x: xMidPoint, w: pointDistance };
                        }),
                    });
                    x += pointDistance;
                };
                var this_1 = this;
                for (var i = 0; i < nrPoints; i++) {
                    _loop_1(i);
                }
            }
            else {
                // charts with bars required a special calculation
                var barWidth_1 = ABeamer.ExprOrNumToNum(params.barWidth, _defValues.barWidth, this.args);
                var seriesSpacing_1 = ABeamer.ExprOrNumToNum(params.seriesSpacing, _defValues.seriesSpacing, this.args);
                if (!barWidth_1) {
                    barWidth_1 = (pointDistance / barChartCount) - seriesSpacing_1;
                }
                var usedPointWidth = barWidth_1 * barChartCount +
                    seriesSpacing_1 * (barChartCount - 1);
                var _loop_2 = function (i) {
                    var xBar = x;
                    var xMidPoint = x + pointDistance / 2;
                    this_2.xDrawPoints.push({
                        x: x,
                        xLabel: x,
                        xLabelWidth: usedPointWidth,
                        series: this_2.data.map(function (_series, seriesI) {
                            if (_this.chartTypes[seriesI] === ChartTypes.bar) {
                                var xBarThis = xBar;
                                xBar += barWidth_1 + seriesSpacing_1;
                                return { x: xBarThis, w: barWidth_1 };
                            }
                            return { x: xMidPoint, w: pointDistance };
                        }),
                    });
                    x += pointDistance;
                };
                var this_2 = this;
                for (var i = 0; i < nrPoints; i++) {
                    _loop_2(i);
                }
            }
            this.x1 = x;
        };
        /** Initializes all the Axis Chart parameters. */
        _WkAxisChart.prototype._initChart = function (params) {
            var _this = this;
            this.chartTypes = this.data.map(function (_series, seriesIndex) {
                if (_this.chartType !== ChartTypes.mixed) {
                    return _this.chartType;
                }
                if (!params.chartTypes || params.chartTypes.length <= seriesIndex) {
                    return ChartTypes.bar;
                }
                return ABeamer.parseEnum(params.chartTypes[seriesIndex], ChartTypes, ChartTypes.bar);
            });
            // axis
            this.xAxis = this._initLine(params.xAxis || {});
            this.yAxis = this._initLine(params.yAxis || {});
            this.y0Line = this._initLine(params.y0Line || {});
            // limits
            this._computeBestValues();
            this.maxValue = ABeamer.ExprOrNumToNum(params.maxValue, this.bestMaxValue, this.args);
            this.minValue = ABeamer.ExprOrNumToNum(params.minValue, Math.min(this.min, 0), this.args);
            this.avgValue = this.avg;
            _super.prototype._initChart.call(this, params);
            // colors
            this.negativeFillColors = !params.negativeFillColors ? this.fillColors :
                this._fillArrayArrayParam(params.negativeFillColors, 'white');
            this._initMarkers(params);
            this._initLabels(params);
            this._computeDrawPoints(params);
            // animation
            this.props['point-height'] = ABeamer.ExprOrNumToNum(params.pointHeightStart, 1, this.args);
            this.props['deviation'] = ABeamer.ExprOrNumToNum(params.deviationStart, 1, this.args);
            this.props['sweep'] = ABeamer.ExprOrNumToNum(params.sweepStart, 1, this.args);
        };
        /** Implements Axis Chart animation. */
        _WkAxisChart.prototype._drawChart = function (params) {
            var _this = this;
            var pointHeight = this.props['point-height'];
            var deviationV = this.props['deviation'];
            var sweepV = this.props['sweep'];
            var chartWidth = this.chartWidth;
            var chartHeight = this.chartHeight;
            var ctx = this.context;
            var x0 = this.graphX0;
            var y0 = this.graphY0;
            var y1 = this.graphY1;
            var topMargin = 1;
            var yLength = y0 - y1 - topMargin;
            // values
            var maxValue = this.maxValue;
            var minValue = this.minValue;
            var valueRange = maxValue - minValue;
            // y0 line
            var hasY0Line = maxValue * minValue < 0;
            var vy0Line = hasY0Line ? 0 : minValue >= 0 ? minValue : maxValue;
            var vy0LineClip = (vy0Line - minValue) / valueRange;
            var axis0Y = y0 - yLength * vy0LineClip;
            // data
            var data = this.data;
            var nrPoints = this.nrPoints;
            var drawNrPoints = sweepV >= 1 ? nrPoints :
                Math.max(Math.min(Math.floor(nrPoints * sweepV) + 1, nrPoints), 0);
            ctx.clearRect(0, 0, chartWidth, chartHeight);
            _super.prototype._drawChart.call(this, params);
            var y = axis0Y;
            var dataMidPixels = [];
            // data points
            data.forEach(function (series, seriesI) {
                var xPrev;
                var yPrev;
                var seriesPixels = [];
                var seriesMidPixels = [];
                var chartType = _this.chartTypes[seriesI];
                for (var i = 0; i < drawNrPoints; i++) {
                    ctx.lineWidth = _this.strokeWidth[seriesI][i];
                    ctx.strokeStyle = _this.strokeColors[seriesI][i];
                    var v = series[i];
                    if (Math.abs(deviationV - 1) > 1e-6) {
                        v = _this.avgValue - ((_this.avgValue - v) * deviationV);
                    }
                    ctx.fillStyle = v >= 0 ? _this.fillColors[seriesI][i] :
                        _this.negativeFillColors[seriesI][i];
                    var xDrawPoint = _this.xDrawPoints[i].series[seriesI];
                    // values
                    var vClip = (v - vy0Line) / valueRange;
                    var vT = vClip * pointHeight;
                    // y
                    var yLen = -yLength * vT;
                    var yNew = yLen + y;
                    // x
                    var x = xDrawPoint.x;
                    var xNew = x;
                    var isSweeping = (i === drawNrPoints - 1) && (sweepV < 1);
                    if (isSweeping) {
                        var leftSweep = (sweepV - i / nrPoints);
                        var reSweep = leftSweep / (1 / nrPoints);
                        xNew = ((xNew - xPrev) * reSweep) + xPrev;
                        yNew = ((yNew - yPrev) * reSweep) + yPrev;
                    }
                    var xMidNew = xNew;
                    var yMidNew = yNew;
                    switch (chartType) {
                        case ChartTypes.bar:
                            var barWidth = xDrawPoint.w;
                            if (isSweeping) {
                                var xSeriesDrawPt = _this.xDrawPoints[i];
                                var xMaxSweepPos = xSeriesDrawPt.xLabel + xSeriesDrawPt.xLabelWidth * sweepV;
                                if (xMaxSweepPos < x) {
                                    barWidth = 0;
                                }
                                else {
                                    barWidth = Math.min(x + barWidth, xMaxSweepPos) - x;
                                }
                            }
                            if (barWidth > 0) {
                                ctx.fillRect(x, y, barWidth, yLen);
                                ctx.strokeRect(x, y, barWidth, yLen);
                            }
                            xMidNew = x + barWidth / 2;
                            break;
                        case ChartTypes.line:
                            if (i) {
                                ctx.beginPath();
                                ctx.moveTo(xPrev, yPrev);
                                ctx.lineTo(xNew, yNew);
                                ctx.stroke();
                            }
                            break;
                    }
                    xPrev = xNew;
                    yPrev = yNew;
                    seriesPixels.push([xNew, yNew]);
                    seriesMidPixels.push([xMidNew, yMidNew]);
                }
                if (chartType === ChartTypes.area) {
                    ctx.beginPath();
                    ctx.moveTo(seriesPixels[0][0], y);
                    seriesPixels.forEach(function (point) {
                        ctx.lineTo(point[0], point[1]);
                    });
                    ctx.lineTo(seriesPixels[seriesPixels.length - 1][0], y);
                    ctx.lineTo(seriesPixels[0][0], y);
                    ctx.fill();
                    ctx.stroke();
                }
                dataMidPixels.push(seriesMidPixels);
            });
            ctx.lineWidth = 1;
            // markers
            if (this.hasMarkers) {
                this._drawMarkers(dataMidPixels);
            }
            // titles
            var titleCaption = this.title.caption;
            if (this.title.caption) {
                _setUpCaptionsFont(this.title, ctx);
                var titleXPos = _alignCaptions(this.title, ctx, titleCaption, this.x1 - this.graphX0);
                ctx.fillText(titleCaption, this.graphX0 + titleXPos, this.title.y);
            }
            var captions;
            // labelsX
            if (this.labelsX) {
                _setUpCaptionsFont(this.labelsX, ctx);
                captions = this.labelsX.captions;
                for (var i = 0; i < captions.length; i++) {
                    var x = this.xDrawPoints[i].xLabel;
                    var text = captions[i];
                    var deltaX = _alignCaptions(this.labelsX, ctx, text, this.xDrawPoints[i].xLabelWidth);
                    ctx.fillText(text, x + deltaX, this.labelsX.y);
                }
            }
            // labelsY
            if (this.labelsY) {
                _setUpCaptionsFont(this.labelsY, ctx);
                captions = this.labelsY.captions;
                var fs2 = this.labelsY.height / 2;
                var scale = yLength / (captions.length - 1);
                for (var i = 0; i < captions.length; i++) {
                    var yi = y0 - scale * i;
                    var text = this.labelsY.captions[i];
                    var deltaX = _alignCaptions(this.labelsY, ctx, text, this.labelsY.width);
                    ctx.fillText(text, this.labelsY.x + deltaX, yi + fs2);
                }
            }
            // y0Line
            if (hasY0Line && this.y0Line.visible) {
                this._drawLine(this.y0Line, x0, axis0Y, this.x1, axis0Y);
            }
            // x-axis
            if (this.xAxis.visible) {
                this._drawLine(this.xAxis, x0, y0, this.x1, y0);
            }
            // y-axis
            if (this.yAxis.visible) {
                this._drawLine(this.yAxis, x0, y0, x0, y0 - yLength);
            }
        };
        return _WkAxisChart;
    }(_WkChart));
    // ------------------------------------------------------------------------
    //                               Pie Chart
    // ------------------------------------------------------------------------
    var _WkPieChart = /** @class */ (function (_super) {
        __extends(_WkPieChart, _super);
        function _WkPieChart() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        _WkPieChart.prototype._initChart = function (params) {
            _super.prototype._initChart.call(this, params);
            // animation
            this.props['angle'] = ABeamer.ExprOrNumToNum(params.angleStart, 0, this.args);
            this.props['dispersion'] = ABeamer.ExprOrNumToNum(params.dispersionStart, 1, this.args);
        };
        _WkPieChart.prototype._drawChart = function (params) {
            var _this = this;
            var angle = this.props['angle'];
            var dispersion = this.props['dispersion'];
            var isClockwise = params.isClockwise !== false;
            var overflow = this.overflow;
            var x0 = this.graphX0 + overflow;
            var y1 = this.graphY1 + overflow;
            var diameter = Math.min(this.graphX1 - x0 - overflow, this.graphY0 - y1 - overflow);
            var radius = diameter / 2;
            var ctx = this.context;
            ctx.clearRect(0, 0, this.chartWidth, this.chartHeight);
            _super.prototype._drawChart.call(this, params);
            this.data.forEach(function (series, seriesI) {
                for (var stage = 0; stage < 2; stage++) {
                    var startAngle = angle;
                    for (var i = 0; i < series.length; i++) {
                        ctx.lineWidth = _this.strokeWidth[seriesI][i];
                        ctx.strokeStyle = _this.strokeColors[seriesI][i];
                        ctx.fillStyle = _this.fillColors[seriesI][i];
                        var point = series[i];
                        var percentage = point / _this.sum;
                        var endAngle = (percentage * Math.PI * 2 * dispersion);
                        if (!isClockwise) {
                            endAngle = -endAngle;
                        }
                        endAngle += startAngle;
                        ctx.beginPath();
                        ctx.moveTo(x0 + radius, y1 + radius);
                        ctx.arc(x0 + radius, y1 + radius, radius, startAngle, endAngle);
                        ctx.closePath();
                        if (stage === 0) {
                            ctx.fill();
                        }
                        else {
                            ctx.stroke();
                        }
                        startAngle = endAngle;
                    }
                }
            });
        };
        return _WkPieChart;
    }(_WkChart));
    // ------------------------------------------------------------------------
    //                               Chart Task
    // ------------------------------------------------------------------------
    ABeamer.pluginManager.addTasks([['chart', _chartTask]]);
    /** Implements the Chart Task */
    function _chartTask(anime, _wkTask, params, stage, args) {
        switch (stage) {
            case ABeamer.TS_INIT:
                var cType_1 = params.chartType;
                if (typeof cType_1 === 'string') {
                    cType_1 = ChartTypes[cType_1];
                }
                var data_1 = params.data;
                if (!data_1.length) {
                    ABeamer.throwErr("Series have empty data");
                }
                var animator_1;
                if (params.animeSelector) {
                    animator_1 = new _ChartVirtualAnimator();
                    animator_1.selector = params.animeSelector;
                    animator_1.params = params;
                    args.story.addVirtualAnimator(animator_1);
                }
                var elAdapters = args.scene.getElementAdapters(anime.selector);
                args.vars.elCount = elAdapters.length;
                elAdapters.forEach(function (elAdapter, elIndex) {
                    args.vars.elIndex = elIndex;
                    var chart;
                    switch (cType_1) {
                        case ChartTypes.pie:
                            chart = new _WkPieChart(args);
                            break;
                        case ChartTypes.marker:
                        case ChartTypes.bar:
                        case ChartTypes.line:
                        case ChartTypes.area:
                        case ChartTypes.mixed:
                            chart = new _WkAxisChart(args);
                            break;
                        default:
                            ABeamer.throwI8n(ABeamer.Msgs.UnknownType, { p: params.chartType });
                    }
                    chart._init(elAdapter, cType_1, animator_1);
                    chart._initData(data_1);
                    chart._initChart(params);
                    chart._drawChart(params);
                    if (animator_1) {
                        animator_1.charts.push(chart);
                    }
                });
                break;
        }
        return ABeamer.TR_EXIT;
    }
    // ------------------------------------------------------------------------
    //                               Testing
    // ------------------------------------------------------------------------
    /* const
      testValues = [3.33, 8.4, 10, 12, 45, 0.12, 100, 1000, 12400, 95000,
        -10, -12, -89.3, -3.4, -400];
  
    testValues.forEach(v => {
      _calcBestMax(v);
    }); */
})(ABeamer || (ABeamer = {}));
//# sourceMappingURL=chart-tasks.js.map