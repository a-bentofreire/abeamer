"use strict";
// ------------------------------------------------------------------------
// Copyright (c) 2018-2024 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License.
// ------------------------------------------------------------------------
// Implements a list of built-in shape Tasks
/** @module end-user | The lines bellow convey information for the end-user */
/**
 * ## Description
 *
 * A **shape task** creates a configurable shape by creating a `svg` tag.
 *
 * This plugin has the following built-in shapes:
 *
 * - `rectangle` - rectangle shape including round rectangle via cx,cy fields.
 * - `line` - x,y and directional shape.
 * - `circle`
 * - `speech` - round rectangle with left and right speech triangle.
 */
var ABeamer;
(function (ABeamer) {
    // #generate-group-section
    // ------------------------------------------------------------------------
    //                               Shape Tasks
    // ------------------------------------------------------------------------
    // The following section contains data for the end-user
    // generated by `gulp build-definition-files`
    // -------------------------------
    // #export-section-start: release
    let Shapes;
    (function (Shapes) {
        Shapes[Shapes["rectangle"] = 0] = "rectangle";
        Shapes[Shapes["line"] = 1] = "line";
        Shapes[Shapes["circle"] = 2] = "circle";
        Shapes[Shapes["speech"] = 3] = "speech";
    })(Shapes = ABeamer.Shapes || (ABeamer.Shapes = {}));
    ABeamer.DEFAULT_SPEECH_START = 10;
    ABeamer.DEFAULT_SPEECH_WIDTH = 10;
    ABeamer.DEFAULT_SPEECH_HEIGHT = 10;
    ABeamer.DEFAULT_SPEECH_SHIFT = 0;
    let SpeechPosition;
    (function (SpeechPosition) {
        SpeechPosition[SpeechPosition["left"] = 0] = "left";
        SpeechPosition[SpeechPosition["right"] = 1] = "right";
    })(SpeechPosition = ABeamer.SpeechPosition || (ABeamer.SpeechPosition = {}));
    // #export-section-end: release
    // -------------------------------
    // ------------------------------------------------------------------------
    //                               Implementation
    // ------------------------------------------------------------------------
    ABeamer.pluginManager.addPlugin({
        id: 'abeamer.shape-tasks',
        uuid: '3e5d5813-348a-4eb1-a8b5-9c87c3988923',
        author: 'Alexandre Bento Freire',
        email: 'abeamer@a-bentofreire.com',
        jsUrls: ['plugins/shape-tasks/shape-tasks.js'],
        teleportable: true,
    });
    // ------------------------------------------------------------------------
    //                               Shape Task
    // ------------------------------------------------------------------------
    ABeamer.pluginManager.addTasks([['shape', _shapeTask]]);
    /** Implements the Shape Task */
    function _shapeTask(anime, _wkTask, params, stage, args) {
        function buildSvg(inTextHtml, shapeTag, width, height, attrs, x0 = 0, y0 = 0) {
            inTextHtml.push(` width="${width}"`);
            inTextHtml.push(` height="${height}"`);
            inTextHtml.push(` viewBox="${x0} ${y0} ${width} ${height}"`);
            inTextHtml.push(` ><${shapeTag}`);
            attrs.forEach(attr => {
                const [name, value] = attr;
                if (value !== undefined) {
                    inTextHtml.push(` ${name}="${value}"`);
                }
            });
        }
        function buildRectangle(inTextHtml, sw, sr) {
            const rw = ABeamer.ExprOrNumToNum(sr.width, 0, args);
            const rh = ABeamer.ExprOrNumToNum(sr.height, 0, args);
            const rx = ABeamer.ExprOrNumToNum(sr.rx, 0, args);
            const ry = ABeamer.ExprOrNumToNum(sr.ry, 0, args);
            buildSvg(inTextHtml, 'rect', rw, rh, [['x', sw], ['y', sw], ['rx', rx], ['ry', ry],
                ['width', rw - 2 * sw], ['height', rh - 2 * sw]]);
        }
        function buildSpeech(inTextHtml, sw, sp) {
            const w = ABeamer.ExprOrNumToNum(sp.width, 0, args);
            const h = ABeamer.ExprOrNumToNum(sp.height, 0, args);
            const srx = ABeamer.ExprOrNumToNum(sp.rx, 0, args);
            const sry = ABeamer.ExprOrNumToNum(sp.ry, 0, args);
            const x0 = -sw;
            const rx = srx || sry || 0;
            const ry = sry || rx || 0;
            const isRound = rx !== 0 && ry !== 0;
            let speechStart = Math.max(sp.speechStart || ABeamer.DEFAULT_SPEECH_START, rx);
            const speechWidth = Math.max(sp.speechWidth || ABeamer.DEFAULT_SPEECH_WIDTH, 0);
            const speechHeight = sp.speechHeight || ABeamer.DEFAULT_SPEECH_HEIGHT;
            let speechShift = sp.speechShift || ABeamer.DEFAULT_SPEECH_SHIFT;
            const path = [];
            // @TODO: fix speech shift
            if (!sp.speechPosition || sp.speechPosition === SpeechPosition.left
                || SpeechPosition[sp.speechPosition] === 'left') {
                speechShift = -speechShift - speechWidth;
                speechStart = w - speechStart - speechWidth;
            }
            path.push(`M${rx} 0 H${w - rx}`);
            if (isRound) {
                path.push(`A ${rx} ${ry} 0 0 1 ${w} ${ry}`);
            }
            path.push(`V${h - ry}`);
            if (isRound) {
                path.push(`A ${rx} ${ry} 0 0 1 ${w - rx} ${h}`);
            }
            path.push(`h${-speechStart}`);
            path.push(`l${speechShift} ${speechHeight}`);
            path.push(`l${-speechWidth - speechShift} ${-speechHeight}`);
            path.push(`H${rx}`);
            if (isRound) {
                path.push(`A ${rx} ${ry} 0 0 1 0 ${h - ry}`);
            }
            path.push(`V${ry}`);
            if (isRound) {
                path.push(`A ${rx} ${ry} 0 0 1 ${rx} 0`);
            }
            buildSvg(inTextHtml, 'path', w + 2 * sw, h + speechHeight + 2 * sw, [['d', path.join(' ')]], x0, -sw);
        }
        function buildArrow(inTextHtml, sa, isArrow) {
            // @TODO: Build Arrow code
            let x = ABeamer.ExprOrNumToNum(sa.x, 0, args);
            let y = ABeamer.ExprOrNumToNum(sa.y, 0, args);
            let x0 = 0;
            let y0 = 0;
            let radDir;
            let len;
            if (params.direction) {
                radDir = ABeamer.ExprOrNumToNum(sa.direction, 0, args) * Math.PI / 180;
                len = ABeamer.ExprOrNumToNum(sa.length, 0, args);
                x = Math.cos(radDir) * len;
                y = Math.sin(radDir) * len;
            }
            else {
                if (isArrow) {
                }
            }
            x0 = Math.min(0, x);
            y0 = Math.min(0, y);
            // if (isArrow) {
            //   const norm = Math.sqrt(x * x + y * y);
            //   // const
            // }
            buildSvg(inTextHtml, 'line', Math.abs(x), Math.abs(y), [['x1', 0], ['y1', 0], ['x2', x], ['y2', y]], x0, y0);
        }
        switch (stage) {
            case ABeamer.TS_INIT:
                const sw = ABeamer.ExprOrNumToNum(params.strokeWidth, 0, args);
                const shape = ABeamer.parseEnum(params.shape, Shapes, Shapes.rectangle);
                const inTextHtml = [`<svg`];
                switch (shape) {
                    case Shapes.rectangle:
                        buildRectangle(inTextHtml, sw, params);
                        break;
                    case Shapes.line:
                        buildArrow(inTextHtml, params, false);
                        break;
                    case Shapes.circle:
                        const r = ABeamer.ExprOrNumToNum(params.radius, 0, args);
                        const r_sw = r + sw;
                        buildSvg(inTextHtml, 'circle', 2 * r_sw, 2 * r_sw, [['cx', r_sw], ['cy', r_sw], ['r', r]]);
                        break;
                    case Shapes.speech:
                        buildSpeech(inTextHtml, sw, params);
                        break;
                    default:
                        return ABeamer.TR_EXIT;
                }
                if (params.fill) {
                    inTextHtml.push(` fill="${params.fill}"`);
                }
                if (params.stroke) {
                    inTextHtml.push(` stroke="${params.stroke}"`);
                }
                if (sw) {
                    inTextHtml.push(` stroke-width="${sw}"`);
                }
                inTextHtml.push('/></svg >');
                const elAdapters = args.scene.getElementAdapters(anime.selector);
                elAdapters.forEach(elAdapter => {
                    elAdapter.setProp('html', elAdapter.getProp('html') +
                        inTextHtml.join(''), args);
                });
                return ABeamer.TR_EXIT;
        }
    }
})(ABeamer || (ABeamer = {}));
//# sourceMappingURL=shape-tasks.js.map