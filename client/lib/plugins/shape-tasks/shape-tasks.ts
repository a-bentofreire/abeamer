"use strict";
// ------------------------------------------------------------------------
// Copyright (c) 2018-2024 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License.
// ------------------------------------------------------------------------

// Implements a list of built-in shape Tasks

/** @module end-user | The lines bellow convey information for the end-user */

/**
 * ## Description
 *
 * A **shape task** creates a configurable shape by creating a `svg` tag.
 *
 * This plugin has the following built-in shapes:
 *
 * - `rectangle` - rectangle shape including round rectangle via cx,cy fields.
 * - `line` - x,y and directional shape.
 * - `circle`
 * - `speech` - round rectangle with left and right speech triangle.
 */
namespace ABeamer {

  // #generate-group-section
  // ------------------------------------------------------------------------
  //                               Shape Tasks
  // ------------------------------------------------------------------------

  // The following section contains data for the end-user
  // generated by `gulp build-definition-files`
  // -------------------------------
  // #export-section-start: release

  export enum Shapes {
    rectangle,
    line,
    circle,
    speech,
  }

  export type ShapeTaskName = 'shape';


  export type ShapeTaskParams =
    | RectangleShapeTaskParams
    | LineShapeTaskParams
    | CircleShapeTaskParams
    | SpeechShapeTaskParams
    ;


  export interface BaseShapeTaskParams extends AnyParams {
    shape?: Shapes | string;
    stroke?: string;
    strokeWidth?: uint | ExprString;
    fill?: string;
  }


  export interface RectangleShapeTaskParams extends BaseShapeTaskParams {
    width?: uint | ExprString;
    height?: uint | ExprString;
    rx?: uint | ExprString;
    ry?: uint | ExprString;
  }


  export interface LineShapeTaskParams extends BaseShapeTaskParams {
    x?: int | ExprString;
    y?: int | ExprString;
    direction?: number | ExprString;
    length?: number | ExprString;
  }


  export interface CircleShapeTaskParams extends BaseShapeTaskParams {
    radius?: number | ExprString;
  }


  export const DEFAULT_SPEECH_START = 10;
  export const DEFAULT_SPEECH_WIDTH = 10;
  export const DEFAULT_SPEECH_HEIGHT = 10;
  export const DEFAULT_SPEECH_SHIFT = 0;


  export enum SpeechPosition {
    left,
    right,
  }


  export interface SpeechShapeTaskParams extends RectangleShapeTaskParams {
    speechPosition?: SpeechPosition | string;
    speechStart?: uint;
    speechWidth?: uint;
    speechHeight?: uint;
    speechShift?: int;
  }

  // #export-section-end: release
  // -------------------------------

  // ------------------------------------------------------------------------
  //                               Implementation
  // ------------------------------------------------------------------------

  pluginManager.addPlugin({
    id: 'abeamer.shape-tasks',
    uuid: '3e5d5813-348a-4eb1-a8b5-9c87c3988923',
    author: 'Alexandre Bento Freire',
    email: 'abeamer@a-bentofreire.com',
    jsUrls: ['plugins/shape-tasks/shape-tasks.js'],
    teleportable: true,
  });

  // ------------------------------------------------------------------------
  //                               Shape Task
  // ------------------------------------------------------------------------

  pluginManager.addTasks([['shape', _shapeTask]]);

  /** Implements the Shape Task */
  function _shapeTask(anime: Animation, _wkTask: WorkTask,
    params: BaseShapeTaskParams, stage: uint, args?: ABeamerArgs): TaskResult {

    function buildSvg(inTextHtml: string[], shapeTag: string,
      width: int, height: uint,
      attrs: [string, string | number][],
      x0: int = 0, y0: int = 0) {

      inTextHtml.push(` width="${width}"`);
      inTextHtml.push(` height="${height}"`);
      inTextHtml.push(` viewBox="${x0} ${y0} ${width} ${height}"`);

      inTextHtml.push(` ><${shapeTag}`);

      attrs.forEach(attr => {
        const [name, value] = attr;
        if (value !== undefined) {
          inTextHtml.push(` ${name}="${value}"`);
        }
      });
    }

    function buildRectangle(inTextHtml: string[],
      sw: number, sr: RectangleShapeTaskParams): void {

      const rw = ExprOrNumToNum(sr.width, 0, args);
      const rh = ExprOrNumToNum(sr.height, 0, args);
      const rx = ExprOrNumToNum(sr.rx, 0, args);
      const ry = ExprOrNumToNum(sr.ry, 0, args);
      buildSvg(inTextHtml, 'rect', rw, rh,
        [['x', sw], ['y', sw], ['rx', rx], ['ry', ry],
        ['width', rw - 2 * sw], ['height', rh - 2 * sw]]);
    }

    function buildSpeech(inTextHtml: string[],
      sw: number, sp: SpeechShapeTaskParams): void {
      const w = ExprOrNumToNum(sp.width, 0, args);
      const h = ExprOrNumToNum(sp.height, 0, args);
      const srx = ExprOrNumToNum(sp.rx, 0, args);
      const sry = ExprOrNumToNum(sp.ry, 0, args);
      const x0 = -sw;
      const rx = srx || sry || 0;
      const ry = sry || rx || 0;
      const isRound = rx !== 0 && ry !== 0;
      let speechStart = Math.max(sp.speechStart || DEFAULT_SPEECH_START, rx);
      const speechWidth = Math.max(sp.speechWidth || DEFAULT_SPEECH_WIDTH, 0);
      const speechHeight = sp.speechHeight || DEFAULT_SPEECH_HEIGHT;
      let speechShift = sp.speechShift || DEFAULT_SPEECH_SHIFT;

      const path = [];

      // @TODO: fix speech shift
      if (!sp.speechPosition || sp.speechPosition === SpeechPosition.left
        || SpeechPosition[sp.speechPosition] === 'left') {
        speechShift = -speechShift - speechWidth;
        speechStart = w - speechStart - speechWidth;
      }

      path.push(`M${rx} 0 H${w - rx}`);
      if (isRound) { path.push(`A ${rx} ${ry} 0 0 1 ${w} ${ry}`); }
      path.push(`V${h - ry}`);
      if (isRound) { path.push(`A ${rx} ${ry} 0 0 1 ${w - rx} ${h}`); }
      path.push(`h${-speechStart}`);
      path.push(`l${speechShift} ${speechHeight}`);
      path.push(`l${-speechWidth - speechShift} ${-speechHeight}`);
      path.push(`H${rx}`);
      if (isRound) { path.push(`A ${rx} ${ry} 0 0 1 0 ${h - ry}`); }
      path.push(`V${ry}`);
      if (isRound) { path.push(`A ${rx} ${ry} 0 0 1 ${rx} 0`); }

      buildSvg(inTextHtml, 'path', w + 2 * sw, h + speechHeight + 2 * sw,
        [['d', path.join(' ')]], x0, -sw);
    }


    function buildArrow(inTextHtml: string[],
      sa: LineShapeTaskParams, isArrow: boolean) {

      // @TODO: Build Arrow code
      let x = ExprOrNumToNum(sa.x, 0, args);
      let y = ExprOrNumToNum(sa.y, 0, args);
      let x0 = 0;
      let y0 = 0;
      let radDir;
      let len;

      if (params.direction) {
        radDir = ExprOrNumToNum(sa.direction, 0, args) * Math.PI / 180;
        len = ExprOrNumToNum(sa.length, 0, args);
        x = Math.cos(radDir) * len;
        y = Math.sin(radDir) * len;
      } else {
        if (isArrow) {

        }
      }
      x0 = Math.min(0, x);
      y0 = Math.min(0, y);

      // if (isArrow) {
      //   const norm = Math.sqrt(x * x + y * y);
      //   // const
      // }

      buildSvg(inTextHtml, 'line', Math.abs(x), Math.abs(y),
        [['x1', 0], ['y1', 0], ['x2', x], ['y2', y]], x0, y0);
    }


    switch (stage) {
      case TS_INIT:
        const sw = ExprOrNumToNum(params.strokeWidth, 0, args);
        const shape = parseEnum(params.shape, Shapes, Shapes.rectangle);
        const inTextHtml = [`<svg`];

        switch (shape) {

          case Shapes.rectangle:
            buildRectangle(inTextHtml, sw, params as RectangleShapeTaskParams);
            break;

          case Shapes.line:
            buildArrow(inTextHtml, params as LineShapeTaskParams, false);
            break;

          case Shapes.circle:
            const r = ExprOrNumToNum((params as CircleShapeTaskParams).radius, 0, args);
            const r_sw = r + sw;
            buildSvg(inTextHtml, 'circle', 2 * r_sw, 2 * r_sw,
              [['cx', r_sw], ['cy', r_sw], ['r', r]]);
            break;

          case Shapes.speech:
            buildSpeech(inTextHtml, sw, params as SpeechShapeTaskParams);
            break;

          default:
            return TR_EXIT;
        }

        if (params.fill) { inTextHtml.push(` fill="${params.fill}"`); }
        if (params.stroke) { inTextHtml.push(` stroke="${params.stroke}"`); }
        if (sw) { inTextHtml.push(` stroke-width="${sw}"`); }
        inTextHtml.push('/></svg >');

        const elAdapters = args.scene.getElementAdapters(anime.selector);
        elAdapters.forEach(elAdapter => {
          elAdapter.setProp('html', elAdapter.getProp('html') +
            inTextHtml.join(''), args);
        });

        return TR_EXIT;
    }
  }
}
